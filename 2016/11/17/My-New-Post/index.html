<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Runtime原理探究参考另一篇文章 Runtime原理探究, 本文主要整理Runtime在实际开发中的应用.
一. 交换方法（method swizzing）涉及到的方法load class_getInstanceMethod class_getClassMethod method_exchangeImplementations method_getImplementation class_ad">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime应用">
<meta property="og:url" content="http://yoursite.com/2016/11/17/My-New-Post/index.html">
<meta property="og:site_name" content="An Guoli's Blog">
<meta property="og:description" content="Runtime原理探究参考另一篇文章 Runtime原理探究, 本文主要整理Runtime在实际开发中的应用.
一. 交换方法（method swizzing）涉及到的方法load class_getInstanceMethod class_getClassMethod method_exchangeImplementations method_getImplementation class_ad">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606df33cd55583b?w=642&h=197&f=png&s=7368">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606df6e8204c1cc?w=700&h=174&f=png&s=13444">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606df6e92299322?w=700&h=192&f=png&s=13302">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606e176be54419d?w=700&h=268&f=png&s=17980">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606e17e4e5b16af?w=510&h=808&f=png&s=146685">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606cd74e62a17d5?w=683&h=229&f=png&s=13971">
<meta property="og:updated_time" content="2017-12-21T03:19:42.138Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime应用">
<meta name="twitter:description" content="Runtime原理探究参考另一篇文章 Runtime原理探究, 本文主要整理Runtime在实际开发中的应用.
一. 交换方法（method swizzing）涉及到的方法load class_getInstanceMethod class_getClassMethod method_exchangeImplementations method_getImplementation class_ad">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2017/12/19/1606df33cd55583b?w=642&h=197&f=png&s=7368">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/11/17/My-New-Post/"/>





  <title> Runtime应用 | An Guoli's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>
<a href="https://github.com/anguoli"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">An Guoli's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/17/My-New-Post/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="安国立">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofutv2nt8.bkt.clouddn.com/blog/image/xiamu.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="An Guoli's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="An Guoli's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Runtime应用
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-17T19:15:17+08:00">
                2016-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Runtime原理探究参考另一篇文章 <a href="https://juejin.im/post/5a37562451882506e50cbc9a" target="_blank" rel="external">Runtime原理探究</a>, 本文主要整理Runtime在实际开发中的应用.</p>
<h2 id="一-交换方法（method-swizzing）"><a href="#一-交换方法（method-swizzing）" class="headerlink" title="一. 交换方法（method swizzing）"></a>一. 交换方法（method swizzing）</h2><p>涉及到的方法<br><code>load</code> <code>class_getInstanceMethod</code> <code>class_getClassMethod</code> <code>method_exchangeImplementations</code> <code>method_getImplementation</code> <code>class_addMethod</code> <code>class_replaceMethod</code></p>
<p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">让你快速上手Runtime 袁峥</a></p>
<ul>
<li><code>开发使用场景</code>:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li><code>方式一</code>:继承系统的类，重写方法.</li>
<li><code>方式二</code>:使用Runtime,交换方法.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view, typically from a nib.</div><div class="line">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</div><div class="line">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</div><div class="line">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</div><div class="line">UIImage *image = [UIImage imageNamed:@&quot;123&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation UIImage (Image)</div><div class="line">// 加载分类到内存的时候调用</div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">// 交换方法</div><div class="line"></div><div class="line">// 获取imageWithName方法地址</div><div class="line">Method imageWithName = class_getClassMethod(self, @selector(imageWithName:));</div><div class="line"></div><div class="line">// 获取imageWithName方法地址</div><div class="line">Method imageName = class_getClassMethod(self, @selector(imageNamed:));</div><div class="line"></div><div class="line">// 交换方法地址，相当于交换实现方式</div><div class="line">method_exchangeImplementations(imageWithName, imageName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</div><div class="line">// 既能加载图片又能打印</div><div class="line">+ (instancetype)imageWithName:(NSString *)name</div><div class="line">&#123;</div><div class="line">// 这里调用imageWithName，相当于调用imageName</div><div class="line">UIImage *image = [self imageWithName:name];</div><div class="line"></div><div class="line">if (image == nil) &#123;</div><div class="line">NSLog(@&quot;加载空的图片&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return image;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">Objective-C中的Runtime LeeJay</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line"></div><div class="line">SEL originalSelector = @selector(willMoveToSuperview:);</div><div class="line">SEL swizzledSelector = @selector(myWillMoveToSuperview:);</div><div class="line"></div><div class="line">Method originalMethod = class_getInstanceMethod(self, originalSelector);</div><div class="line">Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);</div><div class="line"></div><div class="line">BOOL didAddMethod = class_addMethod(self,</div><div class="line">originalSelector,</div><div class="line">method_getImplementation(swizzledMethod),</div><div class="line">method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">if (didAddMethod) &#123;</div><div class="line">class_replaceMethod(self,</div><div class="line">swizzledSelector,</div><div class="line">method_getImplementation(originalMethod),</div><div class="line">method_getTypeEncoding(originalMethod));</div><div class="line">&#125; else &#123;</div><div class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)myWillMoveToSuperview:(UIView *)newSuperview</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;WillMoveToSuperview: %@&quot;, self);</div><div class="line">[self myWillMoveToSuperview:newSuperview];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>1.如果我现在想检查一下项目中有没有内存循环，怎么办？是不是要重写<code>dealloc</code>函数，看下<code>dealloc</code>有没有执行，项目小的时候，一个一个<code>controlle</code>r的写，还不麻烦，如果项目大，要是一个一个的写，估计你会疯掉的。这时候方法交换就派上用场了，你就可以尝试用自己的方法交换系统的<code>dealloc</code>方法，几句代码就搞定了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIViewController+Dealloc.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation UIViewController (Dealloc)</div><div class="line"></div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">Method method1 = class_getInstanceMethod(self, NSSelectorFromString(@&quot;dealloc&quot;));</div><div class="line">Method method2 = class_getInstanceMethod(self, @selector(my_dealloc));</div><div class="line">method_exchangeImplementations(method1, method2);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)my_dealloc</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;%@销毁了&quot;, self);</div><div class="line">[self my_dealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
<li><p>2.数组越界，向数组中添加一个nil对象等等，都会造成闪退，我们可以用自己的方法交换数组相对应的方法。下面是一个交换数组addObject:方法的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSMutableArray+Category.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSMutableArray (Category)</div><div class="line"></div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line"></div><div class="line">SEL originalSelector = @selector(addObject:);</div><div class="line">SEL swizzledSelector = @selector(lj_AddObject:);</div><div class="line"></div><div class="line">// NSMutableArray是类簇，真正的类名是__NSArrayM</div><div class="line">Method originalMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), originalSelector);</div><div class="line">Method swizzledMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), swizzledSelector);</div><div class="line"></div><div class="line">BOOL didAddMethod = class_addMethod(self,</div><div class="line">originalSelector,</div><div class="line">method_getImplementation(swizzledMethod),</div><div class="line">method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">if (didAddMethod)</div><div class="line">&#123;</div><div class="line">class_replaceMethod(self,</div><div class="line">swizzledSelector,</div><div class="line">method_getImplementation(originalMethod),</div><div class="line">method_getTypeEncoding(originalMethod));</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)lj_AddObject:(id)object</div><div class="line">&#123;</div><div class="line">if (object != nil)</div><div class="line">&#123;</div><div class="line">[self lj_AddObject:object];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>PS：我不太建议大家平时开发的时候使用这类数组安全操作的做法，不利于代码的调试，如果真的加入了nil对象，你可能就不会那么容易找出问题在哪，还是在项目发布的时候使用比较合适。</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/f6dad8e1b848" target="_blank" rel="external">Runtime Method Swizzling开发实例汇总（持续更新中） 卖报的小画家Sure</a></p>
<h3 id="Method-Swizzling通用方法封装"><a href="#Method-Swizzling通用方法封装" class="headerlink" title="Method Swizzling通用方法封装"></a>Method Swizzling通用方法封装</h3><p>在列举之前，我们可以将Method Swizzling功能封装为类方法，作为NSObject的类别，这样我们后续调用也会方便些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@interface NSObject (Swizzling)</div><div class="line"></div><div class="line">+ (void)methodSwizzlingWithOriginalSelector:(SEL)originalSelector</div><div class="line">bySwizzledSelector:(SEL)swizzledSelector;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSObject+Swizzling.h&quot;</div><div class="line">@implementation NSObject (Swizzling)</div><div class="line"></div><div class="line">+ (void)methodSwizzlingWithOriginalSelector:(SEL)originalSelector bySwizzledSelector:(SEL)swizzledSelector&#123;</div><div class="line">Class class = [self class];</div><div class="line">//原有方法</div><div class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">//替换原有方法的新方法</div><div class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">//先尝试給源SEL添加IMP，这里是为了避免源SEL没有实现IMP的情况</div><div class="line">BOOL didAddMethod = class_addMethod(class,originalSelector,</div><div class="line">method_getImplementation(swizzledMethod),</div><div class="line">method_getTypeEncoding(swizzledMethod));</div><div class="line">if (didAddMethod) &#123;//添加成功：说明源SEL没有实现IMP，将源SEL的IMP替换到交换SEL的IMP</div><div class="line">class_replaceMethod(class,swizzledSelector,</div><div class="line">method_getImplementation(originalMethod),</div><div class="line">method_getTypeEncoding(originalMethod));</div><div class="line">&#125; else &#123;//添加失败：说明源SEL已经有IMP，直接将两个SEL的IMP交换即可</div><div class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li><strong>为什么要添加didAddMethod判断？</strong><br>先尝试添加原SEL其实是为了做一层保护，因为如果这个类没有实现originalSelector，但其父类实现了，那class_getInstanceMethod会返回父类的方法。这样method_exchangeImplementations替换的是父类的那个方法，这当然不是我们想要的。所以我们先尝试添加 orginalSelector，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。<br>如果理解还不够透彻，我们可以进入runtime.h中查看class_addMethod源码解释：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Adds a new method to a class with a given name and implementation.</div><div class="line">*</div><div class="line">* @param cls The class to which to add a method.</div><div class="line">* @param name A selector that specifies the name of the method being added.</div><div class="line">* @param imp A function which is the implementation of the new method. The function must take at least two arguments—self and _cmd.</div><div class="line">* @param types An array of characters that describe the types of the arguments to the method.</div><div class="line">*</div><div class="line">* @return YES if the method was added successfully, otherwise NO</div><div class="line">*  (for example, the class already contains a method implementation with that name).</div><div class="line">*</div><div class="line">* @note class_addMethod will add an override of a superclass&apos;s implementation,</div><div class="line">*  but will not replace an existing implementation in this class.</div><div class="line">*  To change an existing implementation, use method_setImplementation.</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<p>大概的意思就是我们可以通过class_addMethod为一个类添加方法（包括方法名称（SEL）和方法的实现（IMP）），返回值为BOOL类型，表示方法是否成功添加。 <strong>需要注意的地方是class_addMethod会添加一个覆盖父类的实现，但不会取代原有类的实现。</strong> 也就是说如果class_addMethod返回YES，说明子类中没有方法originalSelector，通过class_addMethod为其添加了方法originalSelector，并使其实现（IMP）为我们想要替换的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class_addMethod(class,originalSelector,</div><div class="line">method_getImplementation(swizzledMethod),</div><div class="line">method_getTypeEncoding(swizzledMethod));</div></pre></td></tr></table></figure></p>
<p>同时再将原有的实现（IMP）替换到swizzledMethod方法上，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class_replaceMethod(class,swizzledSelector,</div><div class="line">method_getImplementation(originalMethod),</div><div class="line">method_getTypeEncoding(originalMethod));</div></pre></td></tr></table></figure></p>
<p>从而实现了方法的交换，并且未影响父类方法的实现。反之如果class_addMethod返回NO，说明子类中本身就具有方法originalSelector的实现，直接调用交换即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</div></pre></td></tr></table></figure></p>
<h3 id="实例一：替换ViewController生命周期方法"><a href="#实例一：替换ViewController生命周期方法" class="headerlink" title="实例一：替换ViewController生命周期方法"></a>实例一：替换ViewController生命周期方法</h3><p>示当前请求情况或进度。这种界面都会存在这样一个问题，在请求较慢时，用户手动退出界面，这时候需要去除加载栏。<br>当然可以依次在每个界面的viewWillDisappear方法中添加去除方法，但如果类似的界面过多，一味的复制粘贴也不是方法。这时候就能体现Method Swizzling的作用了，我们可以替换系统的viewWillDisappear方法，使得每当执行该方法时即自动去除加载栏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIViewController+Swizzling.h&quot;</div><div class="line">#import &quot;NSObject+Swizzling.h&quot;</div><div class="line">@implementation UIViewController (Swizzling)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">[self methodSwizzlingWithOriginalSelector:@selector(viewWillDisappear:) bySwizzledSelector:@selector(sure_viewWillDisappear:)];</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)sure_viewWillDisappear:(BOOL)animated &#123;</div><div class="line">[self sure_viewWillDisappear:animated];</div><div class="line">[SVProgressHUD dismiss];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码如上，这样就不用考虑界面是否移除加载栏的问题了。补充一点，通常我们也会在生命周期方法中设置默认界面背景颜色，因若背景颜色默认为透明对App的性能也有一定影响，这大家可以在UIKit性能优化那篇文章中查阅。但类似该类操作也可以书写在通用类中，所以具体使用还要靠自己定夺。</p>
<h3 id="实例二：解决获取索引、添加、删除元素越界崩溃问题"><a href="#实例二：解决获取索引、添加、删除元素越界崩溃问题" class="headerlink" title="实例二：解决获取索引、添加、删除元素越界崩溃问题"></a>实例二：解决获取索引、添加、删除元素越界崩溃问题</h3><p>对于NSArray、NSDictionary、NSMutableArray、NSMutableDictionary不免会进行索引访问、添加、删除元素的操作，越界问题也是很常见，这时我们可以通过Method Swizzling解决这些问题，越界给予提示防止崩溃。</p>
<p>这里以NSMutableArray为例说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSMutableArray+Swizzling.h&quot;</div><div class="line">#import &quot;NSObject+Swizzling.h&quot;</div><div class="line">@implementation NSMutableArray (Swizzling)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">[objc_getClass(&quot;__NSArrayM&quot;) methodSwizzlingWithOriginalSelector:@selector(removeObject:) bySwizzledSelector:@selector(safeRemoveObject:) ];</div><div class="line">[objc_getClass(&quot;__NSArrayM&quot;) methodSwizzlingWithOriginalSelector:@selector(addObject:) bySwizzledSelector:@selector(safeAddObject:)];</div><div class="line">[objc_getClass(&quot;__NSArrayM&quot;) methodSwizzlingWithOriginalSelector:@selector(removeObjectAtIndex:) bySwizzledSelector:@selector(safeRemoveObjectAtIndex:)];</div><div class="line">[objc_getClass(&quot;__NSArrayM&quot;) methodSwizzlingWithOriginalSelector:@selector(insertObject:atIndex:) bySwizzledSelector:@selector(safeInsertObject:atIndex:)];</div><div class="line">[objc_getClass(&quot;__NSArrayM&quot;) methodSwizzlingWithOriginalSelector:@selector(objectAtIndex:) bySwizzledSelector:@selector(safeObjectAtIndex:)];</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">- (void)safeAddObject:(id)obj &#123;</div><div class="line">if (obj == nil) &#123;</div><div class="line">NSLog(@&quot;%s can add nil object into NSMutableArray&quot;, __FUNCTION__);</div><div class="line">&#125; else &#123;</div><div class="line">[self safeAddObject:obj];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">- (void)safeRemoveObject:(id)obj &#123;</div><div class="line">if (obj == nil) &#123;</div><div class="line">NSLog(@&quot;%s call -removeObject:, but argument obj is nil&quot;, __FUNCTION__);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">[self safeRemoveObject:obj];</div><div class="line">&#125;</div><div class="line">- (void)safeInsertObject:(id)anObject atIndex:(NSUInteger)index &#123;</div><div class="line">if (anObject == nil) &#123;</div><div class="line">NSLog(@&quot;%s can&apos;t insert nil into NSMutableArray&quot;, __FUNCTION__);</div><div class="line">&#125; else if (index &gt; self.count) &#123;</div><div class="line">NSLog(@&quot;%s index is invalid&quot;, __FUNCTION__);</div><div class="line">&#125; else &#123;</div><div class="line">[self safeInsertObject:anObject atIndex:index];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">- (id)safeObjectAtIndex:(NSUInteger)index &#123;</div><div class="line">if (self.count == 0) &#123;</div><div class="line">NSLog(@&quot;%s can&apos;t get any object from an empty array&quot;, __FUNCTION__);</div><div class="line">return nil;</div><div class="line">&#125;</div><div class="line">if (index &gt; self.count) &#123;</div><div class="line">NSLog(@&quot;%s index out of bounds in array&quot;, __FUNCTION__);</div><div class="line">return nil;</div><div class="line">&#125;</div><div class="line">return [self safeObjectAtIndex:index];</div><div class="line">&#125;</div><div class="line">- (void)safeRemoveObjectAtIndex:(NSUInteger)index &#123;</div><div class="line">if (self.count &lt;= 0) &#123;</div><div class="line">NSLog(@&quot;%s can&apos;t get any object from an empty array&quot;, __FUNCTION__);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">if (index &gt;= self.count) &#123;</div><div class="line">NSLog(@&quot;%s index out of bound&quot;, __FUNCTION__);</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">[self safeRemoveObjectAtIndex:index];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>对应大家可以举一反三，相应的实现添加、删除等，以及NSArray、NSDictionary等操作，因代码篇幅较大，这里就不一一书写了。<br>这里没有使用self来调用，而是使用objc_getClass(“__NSArrayM”)来调用的。因为NSMutableArray的真实类只能通过后者来获取，而不能通过[self class]来获取，而method swizzling只对真实的类起作用。这里就涉及到一个小知识点：类簇。补充以上对象对应类簇表。<br><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606df33cd55583b?w=642&amp;h=197&amp;f=png&amp;s=7368" alt="类簇表"></p>
<h3 id="实例三：防止按钮重复暴力点击"><a href="#实例三：防止按钮重复暴力点击" class="headerlink" title="实例三：防止按钮重复暴力点击"></a>实例三：防止按钮重复暴力点击</h3><p>程序中大量按钮没有做连续响应的校验，连续点击出现了很多不必要的问题，例如发表帖子操作，用户手快点击多次，就会导致同一帖子发布多次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">//默认时间间隔</div><div class="line">#define defaultInterval 1</div><div class="line">@interface UIButton (Swizzling)</div><div class="line">//点击间隔</div><div class="line">@property (nonatomic, assign) NSTimeInterval timeInterval;</div><div class="line">//用于设置单个按钮不需要被hook</div><div class="line">@property (nonatomic, assign) BOOL isIgnore;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIButton+Swizzling.h&quot;</div><div class="line">#import &quot;NSObject+Swizzling.h&quot;</div><div class="line"></div><div class="line">@implementation UIButton (Swizzling)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">[self methodSwizzlingWithOriginalSelector:@selector(sendAction:to:forEvent:) bySwizzledSelector:@selector(sure_SendAction:to:forEvent:)];</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSTimeInterval)timeInterval&#123;</div><div class="line">return [objc_getAssociatedObject(self, _cmd) doubleValue];</div><div class="line">&#125;</div><div class="line">- (void)setTimeInterval:(NSTimeInterval)timeInterval&#123;</div><div class="line">objc_setAssociatedObject(self, @selector(timeInterval), @(timeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"></div><div class="line">&#125;</div><div class="line">//当按钮点击事件sendAction 时将会执行sure_SendAction</div><div class="line">- (void)sure_SendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123;</div><div class="line">if (self.isIgnore) &#123;</div><div class="line">//不需要被hook</div><div class="line">[self sure_SendAction:action to:target forEvent:event];</div><div class="line">return;</div><div class="line">&#125;</div><div class="line">if ([NSStringFromClass(self.class) isEqualToString:@&quot;UIButton&quot;]) &#123;</div><div class="line">self.timeInterval =self.timeInterval == 0 ?defaultInterval:self.timeInterval;</div><div class="line">if (self.isIgnoreEvent)&#123;</div><div class="line">return;</div><div class="line">&#125;else if (self.timeInterval &gt; 0)&#123;</div><div class="line">[self performSelector:@selector(resetState) withObject:nil afterDelay:self.timeInterval];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//此处 methodA和methodB方法IMP互换了，实际上执行 sendAction；所以不会死循环</div><div class="line">self.isIgnoreEvent = YES;</div><div class="line">[self sure_SendAction:action to:target forEvent:event];</div><div class="line">&#125;</div><div class="line">//runtime 动态绑定 属性</div><div class="line">- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent&#123;</div><div class="line">// 注意BOOL类型 需要用OBJC_ASSOCIATION_RETAIN_NONATOMIC 不要用错，否则set方法会赋值出错</div><div class="line">objc_setAssociatedObject(self, @selector(isIgnoreEvent), @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">- (BOOL)isIgnoreEvent&#123;</div><div class="line">//_cmd == @select(isIgnore); 和set方法里一致</div><div class="line">return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class="line">&#125;</div><div class="line">- (void)setIsIgnore:(BOOL)isIgnore&#123;</div><div class="line">// 注意BOOL类型 需要用OBJC_ASSOCIATION_RETAIN_NONATOMIC 不要用错，否则set方法会赋值出错</div><div class="line">objc_setAssociatedObject(self, @selector(isIgnore), @(isIgnore), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">- (BOOL)isIgnore&#123;</div><div class="line">//_cmd == @select(isIgnore); 和set方法里一致</div><div class="line">return [objc_getAssociatedObject(self, _cmd) boolValue];</div><div class="line">&#125;</div><div class="line">- (void)resetState&#123;</div><div class="line">[self setIsIgnoreEvent:NO];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="实例四：全局更换控件初始效果"><a href="#实例四：全局更换控件初始效果" class="headerlink" title="实例四：全局更换控件初始效果"></a>实例四：全局更换控件初始效果</h3><p>以UILabel为例，在项目比较成熟的基础上，应用中需要引入新的字体，需要更换所有Label的默认字体，但是同时，对于一些特殊设置了字体的label又不需要更换。乍看起来，这个问题确实十分棘手，首先项目比较大，一个一个设置所有使用到的label的font工作量是巨大的，并且在许多动态展示的界面中，可能会漏掉一些label，产生bug。其次，项目中的label来源并不唯一，有用代码创建的，有xib和storyBoard中的，这也将浪费很大的精力。这时Method Swizzling可以解决此问题，避免繁琐的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#import &quot;UILabel+Swizzling.h&quot;</div><div class="line">#import &quot;NSObject+Swizzling.h&quot;</div><div class="line">@implementation UILabel (Swizzling)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">[self methodSwizzlingWithOriginalSelector:@selector(init) bySwizzledSelector:@selector(sure_Init)];</div><div class="line">[self methodSwizzlingWithOriginalSelector:@selector(initWithFrame:) bySwizzledSelector:@selector(sure_InitWithFrame:)];</div><div class="line">[self methodSwizzlingWithOriginalSelector:@selector(awakeFromNib) bySwizzledSelector:@selector(sure_AwakeFromNib)];</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">- (instancetype)sure_Init&#123;</div><div class="line">id __self = [self sure_Init];</div><div class="line">UIFont * font = [UIFont fontWithName:@&quot;Zapfino&quot; size:self.font.pointSize];</div><div class="line">if (font) &#123;</div><div class="line">self.font=font;</div><div class="line">&#125;</div><div class="line">return __self;</div><div class="line">&#125;</div><div class="line">- (instancetype)sure_InitWithFrame:(CGRect)rect&#123;</div><div class="line">id __self = [self sure_InitWithFrame:rect];</div><div class="line">UIFont * font = [UIFont fontWithName:@&quot;Zapfino&quot; size:self.font.pointSize];</div><div class="line">if (font) &#123;</div><div class="line">self.font=font;</div><div class="line">&#125;</div><div class="line">return __self;</div><div class="line">&#125;</div><div class="line">- (void)sure_AwakeFromNib&#123;</div><div class="line">[self sure_AwakeFromNib];</div><div class="line">UIFont * font = [UIFont fontWithName:@&quot;Zapfino&quot; size:self.font.pointSize];</div><div class="line">if (font) &#123;</div><div class="line">self.font=font;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>这一实例个人认为使用率可能不高，对于产品的设计这些点都是已经确定好的，更改的几率很低。况且我们也可以使用appearance来进行统一设置。</p>
<h3 id="实例六：App异常加载占位图通用类封装（更新于：2016-12-01）"><a href="#实例六：App异常加载占位图通用类封装（更新于：2016-12-01）" class="headerlink" title="实例六：App异常加载占位图通用类封装（更新于：2016/12/01）"></a>实例六：App异常加载占位图通用类封装（更新于：2016/12/01）</h3><p>详情可见文章:<a href="https://www.jianshu.com/p/7fda2d9e9d48" target="_blank" rel="external">《零行代码为App添加异常加载占位图》</a></p>
<p>在该功能模块中，使用Runtime Method Swizzling进行替换tableView、collectionView的reloadData方法，使得每当执行刷新操作时，自动检测当前组数与行数，从而实现零代码判断占位图是否显示的功能，同样也适用于网络异常等情况，详细设置可前往阅读。</p>
<h3 id="实例七：全局修改导航栏后退（返回）按钮（更新于：2016-12-05）"><a href="#实例七：全局修改导航栏后退（返回）按钮（更新于：2016-12-05）" class="headerlink" title="实例七：全局修改导航栏后退（返回）按钮（更新于：2016/12/05）"></a>实例七：全局修改导航栏后退（返回）按钮（更新于：2016/12/05）</h3><p>在真实项目开发中，会全局统一某控件样式，以导航栏后退（返回）按钮为例，通常项目中会固定为返回字样，或者以图片进行显示等。</p>
<p>iOS默认的返回按钮样式如下，默认为蓝色左箭头，文字为上一界面标题文字。<br><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606df6e8204c1cc?w=700&amp;h=174&amp;f=png&amp;s=13444" alt="image.png"><br>这里我们仍可以通过Runtime Method Swizzling来实现该需求，在使用Method Swizzling进行更改之前，必须考虑注意事项，即尽可能的不影响原有操作，比如对于系统默认的返回按钮，与其对应的是有界面边缘右滑返回功能的，因此我们进行统一更改后不可使其功能废弃。</p>
<p>闲话少说，我们创建基于UINavigationItem的类别，在其load方法中替换方法backBarButtonItem<br>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &quot;UINavigationItem+Swizzling.h&quot;</div><div class="line">#import &quot;NSObject+Swizzling.h&quot;</div><div class="line">static char *kCustomBackButtonKey;</div><div class="line">@implementation UINavigationItem (Swizzling)</div><div class="line">+ (void)load &#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">[self methodSwizzlingWithOriginalSelector:@selector(backBarButtonItem)</div><div class="line">bySwizzledSelector:@selector(sure_backBarButtonItem)];</div><div class="line"></div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIBarButtonItem*)sure_backBarButtonItem &#123;</div><div class="line">UIBarButtonItem *backItem = [self sure_backBarButtonItem];</div><div class="line">if (backItem) &#123;</div><div class="line">return backItem;</div><div class="line">&#125;</div><div class="line">backItem = objc_getAssociatedObject(self, &amp;kCustomBackButtonKey);</div><div class="line">if (!backItem) &#123;</div><div class="line">backItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;&quot; style:UIBarButtonItemStylePlain target:nil action:NULL];</div><div class="line">objc_setAssociatedObject(self, &amp;kCustomBackButtonKey, backItem, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">return backItem;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>这里进行将返回按钮的文字清空操作，其他需求样式大家也可随意替换，现在再次运行程序，就会发现所有的返回按钮均只剩左箭头，并右滑手势依然有效。如图所示<br><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606df6e92299322?w=700&amp;h=192&amp;f=png&amp;s=13302" alt="image.png"></p>
<p><a href="http://blog.csdn.net/deft_mkjing/article/details/53789125" target="_blank" rel="external">Runtime基本知识点以及应用场景 deft_mkjing</a></p>
<p>交换方法实现的需求场景：自己创建了一个功能性的方法，在项目中多次被引用，当项目的需求发生改变时，要使用另一种功能代替这个功能，要求是不改变旧的项目(也就是不改变原来方法的实现)。<br>可以在类的分类中，再写一个新的方法(是符合新的需求的),然后交换两个方法的实现。这样，在不改变项目的代码，而只是增加了新的代码 的情况下，就完成了项目的改进。<br>交换两个方法的实现一般写在类的load方法里面，因为load方法会在程序运行前加载一次，而initialize方法会在类或者子类在 第一次使用的时候调用，当有分类的时候会调用多次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// Load的时候如果下面的方法是-方法，那么是无效的，类方法对实例方法无法操作</div><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">Method eatM = class_getClassMethod(self, sel_registerName(&quot;eat:&quot;));</div><div class="line"></div><div class="line">Method sleepM = class_getClassMethod(self, @selector(sleep:));</div><div class="line"></div><div class="line">method_exchangeImplementations(eatM, sleepM);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果要在自己的方法里面调用另个一个方法，直接调用自己的方法名就好了</div><div class="line">+ (void)eat:(NSString *)food</div><div class="line">&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;%@大口吃%@&quot;,NSStringFromClass([self class]),food);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果这样调用直接死循环了</div><div class="line">+ (void)sleep:(NSString *)name</div><div class="line">&#123;</div><div class="line">//    [self eat:@&quot;屎&quot;]; 死循环</div><div class="line"></div><div class="line">NSLog(@&quot;%@睡了%@&quot;,NSStringFromClass([self class]),name);</div><div class="line"></div><div class="line">[self sleep:@&quot;屎&quot;];</div><div class="line">&#125;</div><div class="line">objc_msgSend(objc_getClass(&quot;Dog&quot;), sel_registerName(&quot;eat:&quot;),@&quot;aaa&quot;);</div><div class="line"></div><div class="line">// 打印如下</div><div class="line">// 2016-12-19 17:25:15.699 RuntimeKJ[12219:363270] Dog睡了aaa</div><div class="line">// 2016-12-19 17:25:15.700 RuntimeKJ[12219:363270] Dog大口吃屎</div><div class="line"></div><div class="line">// 先是调用eat的方法，但是由于方法的调换，先调用了sleep方法，在sleep方法里面继续调用sleep，实际上调用的是eat方法，这样就完成的方法调换</div></pre></td></tr></table></figure></p>
<h2 id="二-给分类添加属性"><a href="#二-给分类添加属性" class="headerlink" title="二. 给分类添加属性"></a>二. 给分类添加属性</h2><p>涉及到的方法:<br><code>objc_getAssociatedObject</code> <code>objc_setAssociatedObject</code></p>
<p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">让你快速上手Runtime 袁峥</a><br>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">// 给系统NSObject类动态添加属性name</div><div class="line"></div><div class="line">NSObject *objc = [[NSObject alloc] init];</div><div class="line">objc.name = @&quot;YoonAngel&quot;;</div><div class="line">NSLog(@&quot;%@&quot;,objc.name);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">// 定义关联的key</div><div class="line">static const char *key = &quot;name&quot;;</div><div class="line"></div><div class="line">@implementation NSObject (Property)</div><div class="line"></div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">// 根据关联的key，获取关联的值。</div><div class="line">return objc_getAssociatedObject(self, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">// 第一个参数：给哪个对象添加关联</div><div class="line">// 第二个参数：关联的key，通过这个key获取</div><div class="line">// 第三个参数：关联的value</div><div class="line">// 第四个参数:关联的策略</div><div class="line">objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><a href="http://www.jianshu.com/p/d6a2656fc2cb" target="_blank" rel="external">iOS-Runtime-实践篇  Jerry4me</a></p>
<p>在分类只能对原类扩充方法, 并不能扩充属性, 你可以创建一个分类, 然后在分类中敲几个@property, 然后用第二节的方法打印下原类的property看看存不存在? 答案显然是不存在这个属性.</p>
<p>那么我们可以使用runtime中的一个叫关联对象的办法, 给分类添加一个property, 并且打印原类的property列表是真真切切存在的. 上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// Person+RunningMan.h</div><div class="line">@interface Person (RunningMan)</div><div class="line"></div><div class="line">/** 速度(km/h) */</div><div class="line">@property (nonatomic, assign) CGFloat speed;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// Person+RunningMan.m</div><div class="line">#import &lt;objc/objc-runtime.h&gt;</div><div class="line"></div><div class="line">@implementation Person (RunningMan)</div><div class="line"></div><div class="line">- (CGFloat)speed</div><div class="line">&#123;</div><div class="line">id value = objc_getAssociatedObject(self, _cmd);</div><div class="line">return [value doubleValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setSpeed:(CGFloat)speed</div><div class="line">&#123;</div><div class="line">objc_setAssociatedObject(self, @selector(speed), @(speed), OBJC_ASSOCIATION_ASSIGN);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>好的, 我们看看加了这个分类之后再利用第二节的办法打印下瞧瞧~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">2016-09-04 17:26:00.403 Runtime-实践篇[13795:1050331] ivarName:_name, ivarValue:Kobe</div><div class="line">2016-09-04 17:26:00.404 Runtime-实践篇[13795:1050331] ivarName:_age, ivarValue:18</div><div class="line">2016-09-04 17:26:00.405 Runtime-实践篇[13795:1050331] ivarName:_weight, ivarValue:110</div><div class="line">2016-09-04 17:26:00.405 Runtime-实践篇[13795:1050331] ivarName:_address, ivarValue:值为nil</div><div class="line">2016-09-04 17:26:00.405 Runtime-实践篇[13795:1050331] propertyName:speed, propertyValue:0</div><div class="line">2016-09-04 17:26:00.405 Runtime-实践篇[13795:1050331] propertyName:address, propertyValue:值为nil</div><div class="line">2016-09-04 17:26:00.405 Runtime-实践篇[13795:1050331] propertyName:weight, propertyValue:110</div><div class="line">2016-09-04 17:26:00.405 Runtime-实践篇[13795:1050331] methodName:speed, argumentsCount:0</div><div class="line">2016-09-04 17:26:00.406 Runtime-实践篇[13795:1050331] methodName:setWeight:, argumentsCount:1</div><div class="line">2016-09-04 17:26:00.406 Runtime-实践篇[13795:1050331] methodName:setSpeed:, argumentsCount:1</div><div class="line">2016-09-04 17:26:00.406 Runtime-实践篇[13795:1050331] methodName:weight, argumentsCount:0</div><div class="line">2016-09-04 17:26:00.446 Runtime-实践篇[13795:1050331] methodName:setAddress:, argumentsCount:1</div><div class="line">2016-09-04 17:26:00.447 Runtime-实践篇[13795:1050331] methodName:address, argumentsCount:0</div><div class="line">2016-09-04 17:26:00.447 Runtime-实践篇[13795:1050331] methodName:.cxx_destruct, argumentsCount:0</div></pre></td></tr></table></figure>
<p>看到了嘛? speed这个属性乖乖的在那儿呢.</p>
<p>其实关联对象这个技术就是用哈希表实现的, 将一个类映射到一张哈希表上, 然后根据key找到关联对象, 所以严格说, 关联对象跟本类没有任何联系, 它不是储存在类的内部的. 它的底层原理就不多介绍了, 不属于本文的范畴, 大家感兴趣的可以到以下两篇文章里面看看</p>
<p><a href="https://link.jianshu.com?t=http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></p>
<p><a href="https://link.jianshu.com?t=http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></p>
<p><a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">Objective-C中的Runtime LeeJay</a><br>类别不可以添加属性，我们可以在类别中设置关联，举个栗子：<br>Person+Category.h 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line">@interface Person (Category)</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Person+Category.m 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person+Category.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation Person (Category)</div><div class="line"></div><div class="line">static char *key;</div><div class="line"></div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">objc_setAssociatedObject(self,</div><div class="line">key,</div><div class="line">name,</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">return objc_getAssociatedObject(self, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当然你也可以这么写</p>
<p>Person+Category.m 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person+Category.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation Person (Category)</div><div class="line"></div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">objc_setAssociatedObject(self,</div><div class="line">@selector(name),</div><div class="line">name,</div><div class="line">OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p><code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code>传入的参数key：要求是唯一并且是常量，可以使用static char，然而一个更简单方便的方法就是：使用选择子。由于选择子是唯一并且是常量，你可以使用选择子作为关联的key。（PS：_cmd表示当前调用的方法，它就是一个方法选择器SEL，类似self表示当前对象）</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/7bb5777e0271" target="_blank" rel="external">Objecive-C runtime实践－给Category添加属性</a><br>在开发中经常遇到需要添加hud的情形，每次添加的代码都在10行左右，遂新建一个ViewController的Category来添加hud。由于分类不能直接添加属性，就考虑到了runtime。<br>下面讲具体的实施步骤<br>新建工程－－新建文件，选择Objective-C File 如下图：<br><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606e176be54419d?w=700&amp;h=268&amp;f=png&amp;s=17980" alt=""><br>导入MBProgressHUD, 现在项目结构如图：<br><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606e17e4e5b16af?w=510&amp;h=808&amp;f=png&amp;s=146685" alt=""><br>在UIViewController+HUD.h中导入MBProgressHUD.h，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;MBProgressHUD.h&quot;</div><div class="line">@interface UIViewController (HUD)</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在UIViewController+HUD.m中导入runtime.h，并添加hud属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIViewController+HUD.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface UIViewController(Private)</div><div class="line"></div><div class="line">@property (nonatomic, strong) MBProgressHUD *progressHud;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation UIViewController (HUD)</div><div class="line">const char *kHudKey = &quot;ProgressHUD_Key&quot;;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来是关键的一步－设置hud的setter与getter方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)setProgressHud:(MBProgressHUD *)progressHud</div><div class="line">&#123;</div><div class="line">objc_setAssociatedObject(self, kHudKey, progressHud, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MBProgressHUD *)progressHud</div><div class="line">&#123;</div><div class="line">MBProgressHUD *hud = objc_getAssociatedObject(self, kHudKey);</div><div class="line">if (!hud) &#123;</div><div class="line">UIView *view = self.navigationController.view;</div><div class="line">hud = [[MBProgressHUD alloc] initWithView:view];</div><div class="line">hud.removeFromSuperViewOnHide = YES;</div><div class="line">[view addSubview:hud];</div><div class="line">self.progressHud = hud;</div><div class="line">&#125;</div><div class="line">return hud;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在setter中设置连接， 在getter中初始化。<br>好了，接下来就可以正常使用属性了，现在，我们对hud进行扩展。<br>写两个基本的show、hide方法，其余的实现在其基础上变化即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Private</div><div class="line">- (void)showHudWithMessage:(NSString *)message model:(MBProgressHUDMode)mode</div><div class="line">&#123;</div><div class="line">if (self.progressHud.taskInProgress) &#123;</div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">self.progressHud.taskInProgress = YES;</div><div class="line">self.progressHud.mode = mode ?: MBProgressHUDModeIndeterminate;</div><div class="line">self.progressHud.labelText = message;</div><div class="line">self.progressHud.labelFont = [UIFont systemFontOfSize:15];</div><div class="line">[self.progressHud show:YES];</div><div class="line">[self.progressHud hide:YES afterDelay:15];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)hideHudWithMessage:(NSString *)message image:(UIImage *)image</div><div class="line">&#123;</div><div class="line">self.progressHud.customView = [[UIImageView alloc] initWithImage:image];</div><div class="line">self.progressHud.mode = MBProgressHUDModeCustomView;</div><div class="line">self.progressHud.labelText = message;</div><div class="line">self.progressHud.labelFont = [UIFont systemFontOfSize:15];</div><div class="line"></div><div class="line">[self.progressHud show:YES];</div><div class="line">[self performSelector:@selector(hideHud) withObject:nil afterDelay:0.7];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再实现下面的方法大概就够用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)showHud;</div><div class="line"></div><div class="line">- (void)showHudWithMessage:(NSString *)message;</div><div class="line"></div><div class="line">- (void)showDeterminateHudWithMessage:(NSString *)message;</div><div class="line"></div><div class="line">- (void)changeHudProgress:(double)precent;</div><div class="line"></div><div class="line">- (void)hideHud;</div><div class="line"></div><div class="line">- (void)hideHudWithSuccessMessage:(NSString *)message;</div><div class="line"></div><div class="line">- (void)hideHudWithErrorMessage:(NSString *)message;</div></pre></td></tr></table></figure></p>
<p>具体的实现直接看代码吧！<br><a href="https://github.com/Xigtun/RuntimeDemo" target="_blank" rel="external">https://github.com/Xigtun/RuntimeDemo</a></p>
<h3 id="防止按钮重复暴力点击"><a href="#防止按钮重复暴力点击" class="headerlink" title="防止按钮重复暴力点击"></a>防止按钮重复暴力点击</h3><p>同上</p>
<h3 id="按钮防止被重复点击的方法-iOS"><a href="#按钮防止被重复点击的方法-iOS" class="headerlink" title="按钮防止被重复点击的方法 (iOS)"></a>按钮防止被重复点击的方法 (iOS)</h3><p><a href="http://www.code4app.com/blog-865069-1478.html" target="_blank" rel="external">按钮防止被重复点击的方法 (iOS)</a></p>
<p>避免一个button被多次点击（共总结了3种）<br>第一种：每次在点击时先取消之前的操作<br>将这段代码放在你按钮点击的方法中，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)buttonClicked:(id)sender&#123;</div><div class="line">//点击按钮后先取消之前的操作，再进行需要进行的操作</div><div class="line">[[selfclass]cancelPreviousPerformRequestsWithTarget:selfselector:@selector(buttonClicked:)object:sender];</div><div class="line">[selfperformSelector:@selector(buttonClicked: )withObject:senderafterDelay:0.2f];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：点击后设为不可被点击的状态，几秒后恢复:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)buttonClicked:(id)sender&#123;</div><div class="line">self.button.enabled =NO;</div><div class="line">[selfperformSelector:@selector(changeButtonStatus)withObject:nilafterDelay:1.0f];//防止重复点击</div><div class="line">&#125;</div><div class="line">-(void)changeButtonStatus&#123;</div><div class="line">self.button.enabled =YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三种：使用runtime，一劳永逸我这设的是0.5秒内不会被重复点击<br>1.导入objc / runtime.h（可以放在PCH文件里）</p>
<p>2.创建uicontrol或UIButton的的分类！</p>
<p>创建分类文件：</p>
<p>2.1 打开Xcode中，新建文件，选择OC文件</p>
<p>2.2 在第二个界面，File名为UIControl+UIControl_buttonCon，将文件类型File Type选为Category类，在类里选继承的类别，这里咱们选的Class是UIButton</p>
<p>注：若用Unbutton分类，则会对对Unbutton创建的按钮反应。</p>
<p>2.3 分类创建完毕对分类进行操作<br>.h文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import</div><div class="line">#define defaultInterval.5//默认时间间隔</div><div class="line">@interfaceUIControl (UIControl_buttonCon)</div><div class="line">@property(nonatomic,assign)NSTimeIntervaltimeInterval;//用这个给重复点击加间隔</div><div class="line">@property(nonatomic,assign)BOOLisIgnoreEvent;//YES不允许点击NO允许点击</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>.m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#import&quot;UIControl+UIControl_buttonCon.h&quot;</div><div class="line">@implementationUIControl (UIControl_buttonCon)</div><div class="line">- (NSTimeInterval)timeInterval&#123;</div><div class="line">return[objc_getAssociatedObject(self,_cmd)doubleValue];</div><div class="line">&#125;</div><div class="line">- (void)setTimeInterval:(NSTimeInterval)timeInterval&#123;</div><div class="line">objc_setAssociatedObject(self,@selector(timeInterval),@(timeInterval),OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">//runtime动态绑定属性</div><div class="line">- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent&#123;</div><div class="line">objc_setAssociatedObject(self,@selector(isIgnoreEvent),@(isIgnoreEvent),OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">- (BOOL)isIgnoreEvent&#123;</div><div class="line">return[objc_getAssociatedObject(self,_cmd)boolValue];</div><div class="line">&#125;</div><div class="line">- (void)resetState&#123;</div><div class="line">[selfsetIsIgnoreEvent:NO];</div><div class="line">&#125;</div><div class="line">+ (void)load&#123;</div><div class="line">staticdispatch_once_tonceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">SELselA =@selector(sendAction:to:forEvent:);</div><div class="line">SELselB =@selector(mySendAction:to:forEvent:);</div><div class="line">MethodmethodA =class_getInstanceMethod(self, selA);</div><div class="line">MethodmethodB =class_getInstanceMethod(self, selB);</div><div class="line">//将methodB的实现添加到系统方法中也就是说将methodA方法指针添加成方法methodB的返回值表示是否添加成功</div><div class="line">BOOLisAdd =class_addMethod(self, selA,method_getImplementation(methodB),method_getTypeEncoding(methodB));</div><div class="line">//添加成功了说明本类中不存在methodB所以此时必须将方法b的实现指针换成方法A的，否则b方法将没有实现。</div><div class="line">if(isAdd) &#123;</div><div class="line">class_replaceMethod(self, selB,method_getImplementation(methodA),method_getTypeEncoding(methodA));</div><div class="line">&#125;else&#123;</div><div class="line">//添加失败了说明本类中有methodB的实现，此时只需要将methodA和methodB的IMP互换一下即可。</div><div class="line">method_exchangeImplementations(methodA, methodB);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent*)event&#123;</div><div class="line">if([NSStringFromClass(self.class)isEqualToString:@&quot;UIButton&quot;]) &#123;</div><div class="line">self.timeInterval=self.timeInterval==0?defaultInterval:self.timeInterval;</div><div class="line">if(self.isIgnoreEvent)&#123;</div><div class="line">return;</div><div class="line">&#125;elseif(self.timeInterval&gt;0)&#123;</div><div class="line">[selfperformSelector:@selector(resetState)withObject:nilafterDelay:self.timeInterval];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//此处methodA和methodB方法IMP互换了，实际上执行sendAction；所以不会死循环</div><div class="line">self.isIgnoreEvent=YES;</div><div class="line">[selfmySendAction:actionto:targetforEvent:event];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h2 id="三-字典转模型"><a href="#三-字典转模型" class="headerlink" title="三. 字典转模型"></a>三. 字典转模型</h2><p>涉及到的方法:<br><code>class_copyIvarList</code> <code>ivar_getName</code> <code>ivar_getTypeEncoding</code></p>
<p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">让你快速上手Runtime 袁峥</a></p>
<p>模型属性，通常需要跟字典中的key一一对应,提供一个分类，专门根据字典生成对应的属性字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">@implementation NSObject (Log)</div><div class="line"></div><div class="line"></div><div class="line">// 自动打印属性字符串</div><div class="line">+ (void)resolveDict:(NSDictionary *)dict&#123;</div><div class="line"></div><div class="line">// 拼接属性字符串代码</div><div class="line">NSMutableString *strM = [NSMutableString string];</div><div class="line"></div><div class="line">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</div><div class="line">[dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">// 类型经常变，抽出来</div><div class="line">NSString *type;</div><div class="line"></div><div class="line">if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;</div><div class="line">type = @&quot;NSString&quot;;</div><div class="line">&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;</div><div class="line">type = @&quot;NSArray&quot;;</div><div class="line">&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;</div><div class="line">type = @&quot;int&quot;;</div><div class="line">&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;</div><div class="line">type = @&quot;NSDictionary&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 属性字符串</div><div class="line">NSString *str;</div><div class="line">if ([type containsString:@&quot;NS&quot;]) &#123;</div><div class="line">str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];</div><div class="line">&#125;else&#123;</div><div class="line">str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 每生成属性字符串，就自动换行。</div><div class="line">[strM appendFormat:@&quot;\n%@\n&quot;,str];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 把拼接好的字符串打印出来，就好了。</div><div class="line">NSLog(@&quot;%@&quot;,strM);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<ul>
<li><p>字典转模型的方式一：KVC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- @implementation Status</div><div class="line"></div><div class="line"></div><div class="line">+ (instancetype)statusWithDict:(NSDictionary *)dict</div><div class="line">&#123;</div><div class="line">Status *status = [[self alloc] init];</div><div class="line"></div><div class="line">[status setValuesForKeysWithDictionary:dict];</div><div class="line"></div><div class="line">return status;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
<li><p><code>KVC字典转模型弊端</code>：必须保证，模型中的属性和字典中的key一一对应。</p>
</li>
<li>如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code><br>报key找不到的错。</li>
<li>分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。</li>
<li><p>解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖，<br>就能继续使用KVC，字典转模型了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>字典转模型的方式二：Runtime</p>
</li>
<li><p>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</p>
</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">// 解析Plist文件</div><div class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];</div><div class="line"></div><div class="line">NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];</div><div class="line"></div><div class="line">// 获取字典数组</div><div class="line">NSArray *dictArr = statusDict[@&quot;statuses&quot;];</div><div class="line"></div><div class="line">// 自动生成模型的属性字符串</div><div class="line">//    [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];</div><div class="line"></div><div class="line"></div><div class="line">_statuses = [NSMutableArray array];</div><div class="line"></div><div class="line">// 遍历字典数组</div><div class="line">for (NSDictionary *dict in dictArr) &#123;</div><div class="line"></div><div class="line">Status *status = [Status modelWithDict:dict];</div><div class="line"></div><div class="line">[_statuses addObject:status];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试数据</div><div class="line">NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSObject (Model)</div><div class="line"></div><div class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict</div><div class="line">&#123;</div><div class="line">// 思路：遍历模型中所有属性-》使用运行时</div><div class="line"></div><div class="line">// 0.创建对应的对象</div><div class="line">id objc = [[self alloc] init];</div><div class="line"></div><div class="line">// 1.利用runtime给对象中的成员属性赋值</div><div class="line"></div><div class="line">// class_copyIvarList:获取类中的所有成员属性</div><div class="line">// Ivar：成员属性的意思</div><div class="line">// 第一个参数：表示获取哪个类中的成员属性</div><div class="line">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</div><div class="line">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</div><div class="line">/* 类似下面这种写法</div><div class="line"></div><div class="line">Ivar ivar;</div><div class="line">Ivar ivar1;</div><div class="line">Ivar ivar2;</div><div class="line">// 定义一个ivar的数组a</div><div class="line">Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</div><div class="line"></div><div class="line">// 用一个Ivar *指针指向数组第一个元素</div><div class="line">Ivar *ivarList = a;</div><div class="line"></div><div class="line">// 根据指针访问数组第一个元素</div><div class="line">ivarList[0];</div><div class="line"></div><div class="line">*/</div><div class="line">unsigned int count;</div><div class="line"></div><div class="line">// 获取类中的所有成员属性</div><div class="line">Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class="line"></div><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">// 根据角标，从数组取出对应的成员属性</div><div class="line">Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">// 获取成员属性名</div><div class="line">NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">// 处理成员属性名-&gt;字典中的key</div><div class="line">// 从第一个角标开始截取</div><div class="line">NSString *key = [name substringFromIndex:1];</div><div class="line"></div><div class="line">// 根据成员属性名去字典中查找对应的value</div><div class="line">id value = dict[key];</div><div class="line"></div><div class="line">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</div><div class="line">// 判断下value是否是字典</div><div class="line">if ([value isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">// 字典转模型</div><div class="line">// 获取模型的类对象，调用modelWithDict</div><div class="line">// 模型的类名已知，就是成员属性的类型</div><div class="line"></div><div class="line">// 获取成员属性类型</div><div class="line">NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">// 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot;  在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符</div><div class="line">// 裁剪类型字符串</div><div class="line">NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];</div><div class="line"></div><div class="line">type = [type substringFromIndex:range.location + range.length];</div><div class="line"></div><div class="line">range = [type rangeOfString:@&quot;\&quot;&quot;];</div><div class="line"></div><div class="line">// 裁剪到哪个角标，不包括当前角标</div><div class="line">type = [type substringToIndex:range.location];</div><div class="line"></div><div class="line"></div><div class="line">// 根据字符串类名生成类对象</div><div class="line">Class modelClass = NSClassFromString(type);</div><div class="line"></div><div class="line"></div><div class="line">if (modelClass) &#123; // 有对应的模型才需要转</div><div class="line"></div><div class="line">// 把字典转模型</div><div class="line">value  =  [modelClass modelWithDict:value];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</div><div class="line">// 判断值是否是数组</div><div class="line">if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class="line">// 判断对应类有没有实现字典数组转模型数组的协议</div><div class="line">if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">// 转换成id类型，就能调用任何对象的方法</div><div class="line">id idSelf = self;</div><div class="line"></div><div class="line">// 获取数组中字典对应的模型</div><div class="line">NSString *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">// 生成模型</div><div class="line">Class classModel = NSClassFromString(type);</div><div class="line">NSMutableArray *arrM = [NSMutableArray array];</div><div class="line">// 遍历字典数组，生成模型数组</div><div class="line">for (NSDictionary *dict in value) &#123;</div><div class="line">// 字典转模型</div><div class="line">id model =  [classModel modelWithDict:dict];</div><div class="line">[arrM addObject:model];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 把模型数组赋值给value</div><div class="line">value = arrM;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">if (value) &#123; // 有值，才需要给模型的属性赋值</div><div class="line">// 利用KVC给模型中的属性赋值</div><div class="line">[objc setValue:value forKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">return objc;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">Objective-C中的Runtime LeeJay</a></p>
<p>字典转模型<br>利用Runtime，遍历模型中所有成员变量，根据模型的属性名，去字典中查找key，取出对应的value，给模型的属性赋值，实现的思路主要借鉴MJExtension。</p>
<p>NSObject+Property.h文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol KeyValue &lt;NSObject&gt;</div><div class="line"></div><div class="line">@optional</div><div class="line">/**</div><div class="line">*  数组中需要转换的模型类</div><div class="line">*</div><div class="line">*  @return 字典中的key是数组属性名，value是数组中存放模型的Class（Class类型或者NSString类型）</div><div class="line">*/</div><div class="line">+ (NSDictionary *)objectClassInArray;</div><div class="line"></div><div class="line">/**</div><div class="line">*  将属性名换为其他key去字典中取值</div><div class="line">*</div><div class="line">*  @return 字典中的key是属性名，value是从字典中取值用的key</div><div class="line">*/</div><div class="line">+ (NSDictionary *)replacedKeyFromPropertyName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSObject (Property) &lt;KeyValue&gt;</div><div class="line"></div><div class="line">+ (instancetype)objectWithDictionary:(NSDictionary *)dictionary;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>NSObject+Property.m文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSObject+Property.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSObject (Property)</div><div class="line"></div><div class="line">+ (instancetype)objectWithDictionary:(NSDictionary *)dictionary</div><div class="line">&#123;</div><div class="line">id obj = [[self alloc] init];</div><div class="line"></div><div class="line">// 获取所有的成员变量</div><div class="line">unsigned int count;</div><div class="line">Ivar *ivars = class_copyIvarList(self, &amp;count);</div><div class="line"></div><div class="line">for (unsigned int i = 0; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">Ivar ivar = ivars[i];</div><div class="line"></div><div class="line">// 取出的成员变量，去掉下划线</div><div class="line">NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">NSString *key = [ivarName substringFromIndex:1];</div><div class="line"></div><div class="line">id value = dictionary[key];</div><div class="line"></div><div class="line">// 当这个值为空时，判断一下是否执行了replacedKeyFromPropertyName协议，如果执行了替换原来的key查值</div><div class="line">if (!value)</div><div class="line">&#123;</div><div class="line">if ([self respondsToSelector:@selector(replacedKeyFromPropertyName)])</div><div class="line">&#123;</div><div class="line">NSString *replaceKey = [self replacedKeyFromPropertyName][key];</div><div class="line">value = dictionary[replaceKey];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 字典嵌套字典</div><div class="line">if ([value isKindOfClass:[NSDictionary class]])</div><div class="line">&#123;</div><div class="line">NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];</div><div class="line">type = [type substringFromIndex:range.location + range.length];</div><div class="line">range = [type rangeOfString:@&quot;\&quot;&quot;];</div><div class="line">type = [type substringToIndex:range.location];</div><div class="line">Class modelClass = NSClassFromString(type);</div><div class="line"></div><div class="line">if (modelClass)</div><div class="line">&#123;</div><div class="line">value = [modelClass objectWithDictionary:value];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 字典嵌套数组</div><div class="line">if ([value isKindOfClass:[NSArray class]])</div><div class="line">&#123;</div><div class="line">if ([self respondsToSelector:@selector(objectClassInArray)])</div><div class="line">&#123;</div><div class="line">NSMutableArray *models = [NSMutableArray array];</div><div class="line"></div><div class="line">NSString *type = [self objectClassInArray][key];</div><div class="line">Class classModel = NSClassFromString(type);</div><div class="line">for (NSDictionary *dict in value)</div><div class="line">&#123;</div><div class="line">id model = [classModel objectWithDictionary:dict];</div><div class="line">[models addObject:model];</div><div class="line">&#125;</div><div class="line">value = models;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (value)</div><div class="line">&#123;</div><div class="line">[obj setValue:value forKey:key];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 释放ivars</div><div class="line">free(ivars);</div><div class="line"></div><div class="line">return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://link.jianshu.com?t=http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a></p>
<p><a href="https://link.jianshu.com?t=http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a></p>
<p><a href="https://link.jianshu.com?t=https://www.ianisme.com/ios/2019.html" target="_blank" rel="external">Objective-C Runtime 1小时入门教程</a></p>
<p><a href="https://link.jianshu.com?t=http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）: Method Swizzling</a></p>
<p>iOS开发进阶</p>
<p>Effective Objective-C 2.0<br>附上本文的所有demo下载链接，<a href="https://link.jianshu.com?t=https://github.com/leejayID/RuntimeDemo" target="_blank" rel="external">【GitHub】</a><br>作者：LeeJay<br>链接：<a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">http://www.jianshu.com/p/3e050ec3b759</a></p>
<h3 id="根据字典自动生成属性代码"><a href="#根据字典自动生成属性代码" class="headerlink" title="根据字典自动生成属性代码"></a>根据字典自动生成属性代码</h3><p><a href="http://www.jianshu.com/p/2ad0ebfd5a63" target="_blank" rel="external">http://www.jianshu.com/p/2ad0ebfd5a63</a></p>
<p>日常开发中，我们拿到接口文档，会根据接口返回的数据来写模型。<br>在之前我都是根据返回的字典一个个key这样对照着来创建模型属性。后面遇到项目中有时候返回的数据里面要写成模型属性的key实在是太多，写起来花时间容易写错又没什么技术含量。<br>这时候就应该动用开发人员该有的程序思想了，干脆让它自动生成不就好了。废话不多说上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)createPropertyCode</div><div class="line">&#123;</div><div class="line">NSMutableString *codes = [NSMutableString string];</div><div class="line">// 遍历字典</div><div class="line">[self enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull value, BOOL * _Nonnull stop) &#123;</div><div class="line">NSString *code;</div><div class="line">if ([value isKindOfClass:[NSString class]]) &#123;</div><div class="line">code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSString *%@;&quot;,key];</div><div class="line">&#125; else if ([value isKindOfClass:NSClassFromString(@&quot;__NSCFBoolean&quot;)]) &#123;</div><div class="line">code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) BOOL %@;&quot;,key];</div><div class="line">&#125; else if ([value isKindOfClass:[NSNumber class]]) &#123;</div><div class="line">code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) NSInteger %@;&quot;,key];</div><div class="line">&#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class="line">code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSArray *%@;&quot;,key];</div><div class="line">&#125; else if ([value isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSDictionary *%@;&quot;,key];</div><div class="line">&#125;</div><div class="line">// @property (nonatomic, strong) NSString *source;</div><div class="line">[codes appendFormat:@&quot;\n%@\n&quot;,code];</div><div class="line">&#125;];</div><div class="line">NSLog(@&quot;%@&quot;,codes);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法利用NSDictionary类里面的这个方法帮我们遍历字典里面所有的key和value，期间要做的事情写到block中，也就是帮我们自动生成属性代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)enumerateKeysAndObjectsUsingBlock:(void (^ _Nonnull)(KeyType _Nonnull key, ObjectType _Nonnull obj, BOOL * _Nonnull stop))block</div></pre></td></tr></table></figure></p>
<p>至于怎么用，可以写成NSDictionary的一个分类。然后用字典对象直接调用就好。像这样[dict createPropertyCode]。就可以帮我们打印出属性代码，然后复制粘贴就好。在面对属性超多的模型时，是不是方便许多了。<br>当然你也可以根据需要做一些调整，这里也只是提供一个开发中的小技巧，让机器帮我们做事往往</p>
<p><a href="http://blog.csdn.net/deft_mkjing/article/details/53789125" target="_blank" rel="external">Runtime基本知识点以及应用场景</a></p>
<p>8.使用Runtime和KVC字典转模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)configModelWithDict:(NSDictionary *)jsonDict replaceDict:(NSDictionary *)replaceDict</div><div class="line">&#123;</div><div class="line">id obj = [[self alloc] init];</div><div class="line">unsigned int count = 0;</div><div class="line">// 获取变量列表</div><div class="line">Ivar *ivarLists = class_copyIvarList(self, &amp;count);</div><div class="line">// 遍历逐个进行使用</div><div class="line">for (NSInteger i = 0; i &lt; count; i ++)</div><div class="line">&#123;</div><div class="line">// 获取变量对象</div><div class="line">Ivar ivar = ivarLists[i];</div><div class="line">const char *name = ivar_getName(ivar);</div><div class="line">const char *coding = ivar_getTypeEncoding(ivar); // 判断类型</div><div class="line">// 获取自己写的属性变量字符串 _name</div><div class="line">NSString *nameStr = [[NSString stringWithUTF8String:name] substringFromIndex:1];</div><div class="line">NSString *codingstr = [NSString stringWithUTF8String:coding];</div><div class="line">// 根据字符串在原生字典取值</div><div class="line">id value = jsonDict[nameStr];</div><div class="line">// 如果未取到值  说明字段已经修改了</div><div class="line">if (!value) &#123;</div><div class="line">if (replaceDict) &#123;</div><div class="line">// 然后把修改之前的原生字段拿出来进行取值</div><div class="line">NSString *originValue = replaceDict[nameStr];</div><div class="line">// 再赋值</div><div class="line">value = jsonDict[originValue];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 避免属性数量大于数据数量的时候，如果多出来的属性是对象类型的那正好是null,无影响，如果多出来的属性是普通类型的，那会把nil赋值过去，直接崩溃</div><div class="line">if ([codingstr isEqualToString:@&quot;f&quot;] || [codingstr isEqualToString:@&quot;d&quot;]) &#123;</div><div class="line">value = @(0.0);</div><div class="line">&#125;</div><div class="line">// kvc进行模型组装 这里的value类型和property里面给的属性效果是一致的，如果属性是BOOL，你强行给字符串，实际类型还是BOOL</div><div class="line">[obj setValue:value forKey:nameStr];</div><div class="line">&#125;</div><div class="line">return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面就是转换的核心代码,分析下主要功能参数<br>1.通过class_copyIvarList拿到属性列表的数组，ivar<em>getName这方法拿到属性C类型字符去掉</em>，转换成OC</p>
<p>2.这里会有个问题，如果自己建的model字段和Json返回的字段完全一致，那么就问题不大，但是由于可读性的关系，我们一般都会做一次映射，这就是replaceDict存在的意义，用例如下：<br>当你的属性名字是SubName，但是Json返回的字典key是sub_name,显然是不同的，需要映射，我们根据runtime拿到的key也是SubName，那么你根据字典取值，就会出现空值的问题，因此<br>replaceDict就用到了@{@”SubName”:@”sub_name”}，只要映射好传进去，我们里面就能进一步做判断了</p>
<p>3.直接看代码注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*  1.首先属性小于数据源的时候是肯定没问题的</div><div class="line">*  2.当属性大于数据源的时候，属性是对象，打印出来就是nil，但是如果属性是基本数据类型，直接崩溃</div><div class="line">*  一定要这么判断是否是基本数据类型</div><div class="line">*  避免属性数量大于数据数量的时候，如果多出来的属性是对象类型的那正好是null,无影响，如果多出来的属性是普通类型的，那会把nil赋值过去，直接崩溃</div><div class="line">*  if ([codingstr isEqualToString:@&quot;f&quot;] || [codingstr isEqualToString:@&quot;d&quot;]) &#123;</div><div class="line">*  value = @(0.0);</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>这里的F,D什么类型可以参考官方文档类型<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">type类型文档</a></p>
<p>理解了字段和原理，调用代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 1.URL</div><div class="line">NSString *githubAPI = @&quot;https://api.github.com/users/Tuccuay&quot;;</div><div class="line"></div><div class="line">// 2.创建请求对象</div><div class="line">// 对象内部已经包含了请求方法和请求头（GET）</div><div class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:githubAPI]];</div><div class="line"></div><div class="line">// 3.创建session单例</div><div class="line">NSURLSession *session = [NSURLSession sharedSession];</div><div class="line"></div><div class="line">// 4.根据会话对象发送请求</div><div class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil];</div><div class="line">MKJModel *mkj = [MKJModel configModelWithDict:jsonDict replaceDict:@&#123;@&quot;mkjLogin&quot;:@&quot;login&quot;,</div><div class="line">@&quot;mkjID&quot;:@&quot;id&quot;,</div><div class="line">@&quot;mkjAvatar_url&quot;:@&quot;avatar_url&quot;,</div><div class="line">@&quot;mkjGravatar_id&quot;:@&quot;gravatar_id&quot;,</div><div class="line">@&quot;mkjUrl&quot;:@&quot;url&quot;,</div><div class="line">@&quot;mkjHtml_url&quot;:@&quot;html_url&quot;,</div><div class="line">@&quot;mkjFollowers_url&quot;:@&quot;followers_url&quot;,</div><div class="line">@&quot;mkjFollowing_url&quot;:@&quot;following_url&quot;,</div><div class="line">@&quot;mkjGists_url&quot;:@&quot;gists_url&quot;,</div><div class="line">@&quot;mkjStarred_url&quot;:@&quot;starred_url&quot;,</div><div class="line">&#125;];</div><div class="line">NSLog(@&quot;%@&quot;,mkj);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">// 5.task resume</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure></p>
<h2 id="四-动态添加一个类"><a href="#四-动态添加一个类" class="headerlink" title="四. 动态添加一个类"></a>四. 动态添加一个类</h2><p>涉及方法 <code>objc_allocateClassPair</code>  <code>class_addIvar</code> <code>objc_registerClassPair</code> <code>class_getInstanceVariable</code> <code>objc_disposeClassPair</code> <code>class_addMethod</code>  <code>performSelector</code></p>
<p><a href="http://www.jianshu.com/p/d6a2656fc2cb" target="_blank" rel="external">iOS-Runtime-实践篇  Jerry4me</a></p>
<p>所有runtime代码都是基于C的函数, 所以要用到runtime的函数必须导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/objc-runtime.h&gt; // 模拟器</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt; // 真机</div><div class="line">#import &lt;objc/message.h&gt; // 真机</div></pre></td></tr></table></figure></p>
<p>就像KVO一样, 系统是在程序运行的时候根据你要监听的类, 动态添加一个新类继承自该类, 然后重写原类的setter方法并在里面通知observer的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 创建一个类(size_t extraBytes该参数通常指定为0, 该参数是分配给类和元类对象尾部的索引ivars的字节数。)</div><div class="line">Class clazz = objc_allocateClassPair([NSObject class], &quot;GoodPerson&quot;, 0);</div><div class="line"></div><div class="line">// 添加ivar</div><div class="line">// @encode(aType) : 返回该类型的内部表示字符串, 如@encode(int) -&gt; i</div><div class="line">class_addIvar(clazz, &quot;_name&quot;, sizeof(NSString *), log2(sizeof(NSString *)), @encode(NSString *));</div><div class="line"></div><div class="line">class_addIvar(clazz, &quot;_age&quot;, sizeof(NSUInteger), log2(sizeof(NSUInteger)), @encode(NSUInteger));</div><div class="line"></div><div class="line">// 注册该类</div><div class="line">objc_registerClassPair(clazz);</div><div class="line"></div><div class="line">// 创建实例对象</div><div class="line">id object = [[clazz alloc] init];</div><div class="line"></div><div class="line">// 设置ivar</div><div class="line">[object setValue:@&quot;Tracy&quot; forKey:@&quot;name&quot;];</div><div class="line"></div><div class="line">Ivar ageIvar = class_getInstanceVariable(clazz, &quot;_age&quot;);</div><div class="line">object_setIvar(object, ageIvar, @18);</div><div class="line"></div><div class="line">// 打印对象的类和内存地址</div><div class="line">NSLog(@&quot;%@&quot;, object);</div><div class="line"></div><div class="line">// 打印对象的属性值</div><div class="line">NSLog(@&quot;name = %@, age = %@&quot;, [object valueForKey:@&quot;name&quot;], object_getIvar(object, ageIvar));</div><div class="line"></div><div class="line">// 当类或者它的子类的实例还存在，则不能调用objc_disposeClassPair方法</div><div class="line">object = nil;</div><div class="line"></div><div class="line">// 销毁类</div><div class="line">objc_disposeClassPair(clazz);</div></pre></td></tr></table></figure></p>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-09-04 17:04:08.328 Runtime-实践篇[13699:1043458] &lt;GoodPerson: 0x1002039b0&gt;</div><div class="line">2016-09-04 17:04:08.329 Runtime-实践篇[13699:1043458] name = Tracy, age = 18</div></pre></td></tr></table></figure>
<p>这样, 我们就在程序运行时动态添加了一个继承自NSObject的GoodPerson类, 并为该类添加了name和age成员变量. 这里我们需要注意的是, 添加成员变量的<code>class_addIvar</code>方法必须要在<code>objc_allocateClassPair</code>和<code>objc_registerClassPair</code>之间调用才行, 这里涉及到OC中类的成员变量的偏移量, 如果在类注册之后再addIvar的话会破坏原来类成员变量正确的偏移量, 这样的话会导致你访问的那个成员变量并不是你想访问的成员变量, 如图 :</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606cd74e62a17d5?w=683&amp;h=229&amp;f=png&amp;s=13971" alt="在类中新增另一个实例变量前后的数据布局图"></p>
<p>大家可以试试把<code>class_addIvar</code>方法放在<code>objc_registerClassPair</code>方法之后执行, 看看会发生什么? (用KVC赋值和取值直接报错, 用getIvar的话取值为null)</p>
<p><a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">Objective-C中的Runtime LeeJay</a></p>
<p>一、动态的创建一个类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 创建一个名为People的类，它是NSObject的子类</div><div class="line">Class People = objc_allocateClassPair([NSObject class], &quot;People&quot;, 0);</div><div class="line"></div><div class="line">// 为该类添加一个eat的方法</div><div class="line">class_addMethod(People, NSSelectorFromString(@&quot;eat&quot;), (IMP) eatFun, &quot;v@:&quot;);</div><div class="line"></div><div class="line">// 注册该类</div><div class="line">objc_registerClassPair(People);</div><div class="line"></div><div class="line">// 创建一个People的实例对象p</div><div class="line">id p = [[People alloc] init];</div><div class="line"></div><div class="line">// 调用eat方法</div><div class="line">[p performSelector:@selector(eat)];</div></pre></td></tr></table></figure></p>
<h2 id="五-打印一个类的所有ivar-property-和-method"><a href="#五-打印一个类的所有ivar-property-和-method" class="headerlink" title="五. 打印一个类的所有ivar, property 和 method"></a>五. 打印一个类的所有ivar, property 和 method</h2><p><a href="http://www.jianshu.com/p/d6a2656fc2cb" target="_blank" rel="external">iOS-Runtime-实践篇</a></p>
<p>这个还是比较简单的, 应该直接看代码都能看懂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">Person *p = [[Person alloc] init];</div><div class="line">[p setValue:@&quot;Kobe&quot; forKey:@&quot;name&quot;];</div><div class="line">[p setValue:@18 forKey:@&quot;age&quot;];</div><div class="line">//    p.address = @&quot;广州大学城&quot;;</div><div class="line">p.weight = 110.0f;</div><div class="line"></div><div class="line">// 1.打印所有ivars</div><div class="line">unsigned int ivarCount = 0;</div><div class="line">// 用一个字典装ivarName和value</div><div class="line">NSMutableDictionary *ivarDict = [NSMutableDictionary dictionary];</div><div class="line">Ivar *ivarList = class_copyIvarList([p class], &amp;ivarCount);</div><div class="line">for(int i = 0; i &lt; ivarCount; i++)&#123;</div><div class="line">NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivarList[i])];</div><div class="line">id value = [p valueForKey:ivarName];</div><div class="line"></div><div class="line">if (value) &#123;</div><div class="line">ivarDict[ivarName] = value;</div><div class="line">&#125; else &#123;</div><div class="line">ivarDict[ivarName] = @&quot;值为nil&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 打印ivar</div><div class="line">for (NSString *ivarName in ivarDict.allKeys) &#123;</div><div class="line">NSLog(@&quot;ivarName:%@, ivarValue:%@&quot;,ivarName, ivarDict[ivarName]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.打印所有properties</div><div class="line">unsigned int propertyCount = 0;</div><div class="line">// 用一个字典装propertyName和value</div><div class="line">NSMutableDictionary *propertyDict = [NSMutableDictionary dictionary];</div><div class="line">objc_property_t *propertyList = class_copyPropertyList([p class], &amp;propertyCount);</div><div class="line">for(int j = 0; j &lt; propertyCount; j++)&#123;</div><div class="line">NSString *propertyName = [NSString stringWithUTF8String:property_getName(propertyList[j])];</div><div class="line">id value = [p valueForKey:propertyName];</div><div class="line"></div><div class="line">if (value) &#123;</div><div class="line">propertyDict[propertyName] = value;</div><div class="line">&#125; else &#123;</div><div class="line">propertyDict[propertyName] = @&quot;值为nil&quot;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 打印property</div><div class="line">for (NSString *propertyName in propertyDict.allKeys) &#123;</div><div class="line">NSLog(@&quot;propertyName:%@, propertyValue:%@&quot;,propertyName, propertyDict[propertyName]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 3.打印所有methods</div><div class="line">unsigned int methodCount = 0;</div><div class="line">// 用一个字典装methodName和arguments</div><div class="line">NSMutableDictionary *methodDict = [NSMutableDictionary dictionary];</div><div class="line">Method *methodList = class_copyMethodList([p class], &amp;methodCount);</div><div class="line">for(int k = 0; k &lt; methodCount; k++)&#123;</div><div class="line">SEL methodSel = method_getName(methodList[k]);</div><div class="line">NSString *methodName = [NSString stringWithUTF8String:sel_getName(methodSel)];</div><div class="line"></div><div class="line">unsigned int argumentNums = method_getNumberOfArguments(methodList[k]);</div><div class="line"></div><div class="line">methodDict[methodName] = @(argumentNums - 2); // -2的原因是每个方法内部都有self 和 selector 两个参数</div><div class="line">&#125;</div><div class="line">// 打印method</div><div class="line">for (NSString *methodName in methodDict.allKeys) &#123;</div><div class="line">NSLog(@&quot;methodName:%@, argumentsCount:%@&quot;, methodName, methodDict[methodName]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果为 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">2016-09-04 17:06:49.070 Runtime-实践篇[13723:1044813] ivarName:_name, ivarValue:Kobe</div><div class="line">2016-09-04 17:06:49.071 Runtime-实践篇[13723:1044813] ivarName:_age, ivarValue:18</div><div class="line">2016-09-04 17:06:49.071 Runtime-实践篇[13723:1044813] ivarName:_weight, ivarValue:110</div><div class="line">2016-09-04 17:06:49.072 Runtime-实践篇[13723:1044813] ivarName:_address, ivarValue:值为nil</div><div class="line">2016-09-04 17:06:49.072 Runtime-实践篇[13723:1044813] propertyName:address, propertyValue:值为nil</div><div class="line">2016-09-04 17:06:49.072 Runtime-实践篇[13723:1044813] propertyName:weight, propertyValue:110</div><div class="line">2016-09-04 17:06:49.073 Runtime-实践篇[13723:1044813] methodName:setWeight:, argumentsCount:1</div><div class="line">2016-09-04 17:06:49.073 Runtime-实践篇[13723:1044813] methodName:weight, argumentsCount:0</div><div class="line">2016-09-04 17:06:49.074 Runtime-实践篇[13723:1044813] methodName:setAddress:, argumentsCount:1</div><div class="line">2016-09-04 17:06:49.074 Runtime-实践篇[13723:1044813] methodName:address, argumentsCount:0</div><div class="line">2016-09-04 17:06:49.074 Runtime-实践篇[13723:1044813] methodName:.cxx_destruct, argumentsCount:0</div></pre></td></tr></table></figure></p>
<p>前面2节主要是熟悉runtime的函数调用, 毕竟有许多函数前缀<code>objc</code>, <code>class</code>, <code>object</code>等等. 其实这里面也有规律 :</p>
<ul>
<li><code>objc_</code>: 高于类的操作, 例如添加类, 注册类, 销毁类还有许多高于一个类本身的操作一般都是objc开头</li>
<li><code>class</code> : 对类的内部进行修改的, 例如添加ivar, 添加property, 添加method等等</li>
<li><code>object</code> : 对某个对象进行修改, 例如设置ivar值, 获取ivar值, 设置property值, 获取property值, 调用某个method等等</li>
<li><code>ivar</code>, <code>property</code>, <code>method</code> : 这三个方法大家可以手动去敲敲看一看</li>
</ul>
<h2 id="六-动态添加方法"><a href="#六-动态添加方法" class="headerlink" title="六. 动态添加方法"></a>六. 动态添加方法</h2><p>涉及方法:<br><code>performSelector</code>  <code>resolveInstanceMethod</code> <code>class_addMethod</code></p>
<p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="external">让你快速上手Runtime 袁峥</a></p>
<ul>
<li><code>开发使用场景</code>：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li><code>经典面试题</code>：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li><code>简单使用</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</div><div class="line">// 动态添加方法就不会报错</div><div class="line">[p performSelector:@selector(eat)];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation Person</div><div class="line">// void(*)()</div><div class="line">// 默认方法都有两个隐式参数，</div><div class="line">void eat(id self,SEL sel)</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</div><div class="line">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line"></div><div class="line">if (sel == @selector(eat)) &#123;</div><div class="line">// 动态添加eat方法</div><div class="line"></div><div class="line">// 第一个参数：给哪个类添加方法</div><div class="line">// 第二个参数：添加方法的方法编号</div><div class="line">// 第三个参数：添加方法的函数实现（函数地址）</div><div class="line">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</div><div class="line">class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="动态添加方法实现"><a href="#动态添加方法实现" class="headerlink" title="动态添加方法实现"></a>动态添加方法实现</h3><p><a href="http://www.jianshu.com/p/d6a2656fc2cb" target="_blank" rel="external">iOS-Runtime-实践篇</a></p>
<p>好了, 绕来绕去又回到了runtime强大的消息转发身上了, 当一个方法没有实现的时候, OC会怎么做的呢? 还记得那四个步骤吗, 不记得也没关系, 我们看代码!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">Person类只有- (void)noIMPMethod方法的声明,</div><div class="line">没有他的实现, 一般来说程序运行, 调用noIMPMethod这个方法, 肯定要报错的,</div><div class="line">我们可以在这个方法里动态添加该方法的实现</div><div class="line">*/</div><div class="line"></div><div class="line">// 用来实现noIMPMethod方法实现的函数</div><div class="line">void otherFunction(id self, SEL cmd)</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;动态处理了noIMPMethod方法的实现&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第一步, 对象在收到无法解读的消息后, 首先调用其所属类的这个类方法</div><div class="line">// 返回YES则结束消息转发, 返回NO则进入下一步</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">// 如果是noIMPMethod方法</div><div class="line">if([NSStringFromSelector(sel) isEqualToString:@&quot;noIMPMethod&quot;])&#123;</div><div class="line">// 动态添加方法实现</div><div class="line">class_addMethod([self class], sel, (IMP)otherFunction, &quot;v@:&quot;);</div><div class="line">return YES;</div><div class="line">&#125; else &#123;</div><div class="line">return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序运行结果 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-09-04 17:38:24.301 Runtime-实践篇[13856:1054351] 动态处理了noIMPMethod方法的实现</div><div class="line">代码应该也很明了, 当判断到无法解读的SEL后, 可以给该SEL动态添加方法的实现.</div></pre></td></tr></table></figure></p>
<p><em>ps : 消息转发的另外3个方法会在下文放上, 因为本例子用不上所以就不放上来了</em></p>
<p><a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">Objective-C中的Runtime LeeJay</a></p>
<p>二、动态的给某个类添加方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">if ([NSStringFromSelector(sel) isEqualToString:@&quot;doSomething&quot;])</div><div class="line">&#123;</div><div class="line">class_addMethod(self, sel, (IMP) doSomething, &quot;v@:@&quot;);</div><div class="line">&#125;</div><div class="line">return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>动态的给某个类添加方法，<code>class_addMethod</code>的参数：<br>self：给哪个类添加方法<br>sel：添加方法的方法编号（选择子）<br>IMP：添加方法的函数实现(函数地址)<br>types 函数的类型,(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</p>
</blockquote>
<p><a href="http://blog.csdn.net/deft_mkjing/article/details/53789125" target="_blank" rel="external">Runtime基本知识点以及应用场景</a></p>
<p>动态添加方法</p>
<p>通常做法都是在resolve方法内部指定sel的IMP，前提是该方法未实现会被拦截下来，就能实现动态创建的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">void run (id self, SEL _cmd,NSNumber *meter,NSString *name)</div><div class="line">&#123;</div><div class="line">// implementation .....</div><div class="line">NSLog(@&quot;%@跑了%@&quot;,name,meter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//对实现(abc)的前两个参数的说明</div><div class="line">//每个方法的内部都默认包含两个参数，被称为隐式参数</div><div class="line">//id类型self(代表类或对象)和SEL类型的_cmd(方法编号)</div><div class="line">//class_addMethod函数参数的含义:</div><div class="line">//第一个参数Class cls, 类型</div><div class="line">//第二个参数SEL name, 被解析的方法</div><div class="line">//第三个参数 IMP imp, 指定的实现</div><div class="line">//第四个参数const char *types,方法的类型，具体参照类型的codeType那张图，但是要注意一点：Since the function must take at least two arguments—self and _cmd, the second and third characters must be “@:” (the first character is the return type).译为：因为函数必须至少有两个参数self和_cmd,第二个和第三个字符必须是“@:”。如果想要再增加参数，就可以从实现的第三个参数算起，看下面的例子就明白。</div><div class="line">// 当调用有未实现的实例方法的时候会进到这里来</div><div class="line">+ (BOOL) resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">// 多参数就是&quot;run:&quot;无参数就是run</div><div class="line">if (aSEL == @selector(run:))</div><div class="line">&#123;</div><div class="line">class_addMethod([self class], aSEL, (IMP) run, &quot;v@:@:@&quot;);// 增加了2个对象类型参数 增加了@</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line">//    return [super resolveInstanceMethod:aSEL];</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当调用类方法未实现的时候+ (BOOL)resolveClassMethod:(SEL)sel 在这里拦截</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;类方法未实现&quot;);</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="七-消息转发"><a href="#七-消息转发" class="headerlink" title="七. 消息转发"></a>七. 消息转发</h2><p>动态消息转发<br>和上面一样我们创建的对象调用未实现的方法时，类和实例变量的内部是可以这样进行转发的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#pragma mark - 对象方法</div><div class="line">// 没有实现firstMethod的方法</div><div class="line"></div><div class="line">// 1. 在没有找到方法时，会先调用此方法，和DynicmicInsatance的方法一样就可以动态添加方法3</div><div class="line">//    返回YES 表示响应的Selector的实现已经被找到并添加到子类中了</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">//    if (sel == @selector(touch)) &#123;</div><div class="line">//        class_addMethod([self class], sel, (IMP)touch, &quot;v@:&quot;);</div><div class="line">//    &#125;</div><div class="line">return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.第二步</div><div class="line">//   第一步里面返回之后没有添加新方法，该方法就会被调用，在这个方法中，我们可以指定一个可以返回一个响应方法的独享</div><div class="line">//   不能返回Self 死循环</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 3.第三步</div><div class="line">//   如果上面返回了nil则该方法会被调用，给系统一个需要的编码</div><div class="line">//   如果这里放回的是nil，那是无法执行下一波的，下次无法得到处理</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 4.第四步</div><div class="line">// 调用转发消息方法</div><div class="line">- (void)second</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;对象方法first方法未被调用，消息转发成了second方法&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 该方法不进行重写就直接进入第五步</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">[anInvocation setSelector:@selector(second)];</div><div class="line">[anInvocation invokeWithTarget:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 5.第五步</div><div class="line">// 如果没有调用第四步的转发，那么会进入异常</div><div class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;无法处理的消息:%@&quot;,NSStringFromSelector(aSelector));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>先在这里拦截resolveInstanceMethod</li>
<li>第一步未动态添加的话就调用forwardingTargetForSelector</li>
<li>第二步返回nil来到这里调用methodSignatureForSelector签名</li>
<li>重定向消息指针，实现消息转发</li>
<li>如果没有实现第四步就doesNotRecognizeSelector异常</li>
</ul>
<h2 id="八-更换方法调用者"><a href="#八-更换方法调用者" class="headerlink" title="八. 更换方法调用者"></a>八. 更换方法调用者</h2><p><a href="http://www.jianshu.com/p/d6a2656fc2cb" target="_blank" rel="external">iOS-Runtime-实践篇  Jerry4me</a></p>
<p>试想一下, 一个腿部残疾的人, 他想跑, runtime知道他自己跑不了, 于是就让他的狗替代他去跑了(person没有run方法的声明和实现, dog有run方法的声明和实现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 第一步, 对象在收到无法解读的消息后, 首先调用其所属类的这个类方法</div><div class="line">// 返回YES则结束消息转发, 返回NO则进入下一步</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二步, 动态方法解析失败, 则调用这个方法</div><div class="line">// 返回的对象将处理该selector, 返回nil则进入下一步</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第三步, 在这里返回方法的消息签名</div><div class="line">// 返回YES则进入下一步, 返回nil则结束消息转发</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run&quot;])&#123;</div><div class="line">return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</div><div class="line">&#125; else &#123;</div><div class="line">return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第四步, 最后一次处理该消息的机会</div><div class="line">// 这里处理不了这个invocation就会结束消息转发</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">// 在这我们修改调用该方法的对象</div><div class="line">Dog *dog = [[Dog alloc] init];</div><div class="line">// 让dog去调用该方法</div><div class="line">[anInvocation invokeWithTarget:dog];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我们通过<code>((void(*)(id, SEL))objc_msgSend)((id)p, @selector(run)); // 这里强转是为了不让编译器报参数过多的错误方法</code>调用person的run方法, 得到的输出为 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-09-04 17:49:42.634 Runtime-实践篇[13939:1059419] 是狗在跑步</div></pre></td></tr></table></figure></p>
<p>同样, 其实可以在第二部就把这件事做了, 只需返回dog实例即可, 大家可以亲手操作试试</p>
<h2 id="九-更改特定方法的实现"><a href="#九-更改特定方法的实现" class="headerlink" title="九. 更改特定方法的实现"></a>九. 更改特定方法的实现</h2><p><a href="http://www.jianshu.com/p/d6a2656fc2cb" target="_blank" rel="external">iOS-Runtime-实践篇  Jerry4me</a></p>
<p>一条狗在吃着骨头, 然后他的主人一把把一个球扔得远远的, 碍于主人的淫威之下, 狗就不得不停下来跑去捡球了(<code>更改[dog eat]方法的实现为[dog run]</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 第一步, 对象在收到无法解读的消息后, 首先调用其所属类的这个类方法</div><div class="line">// 返回YES则结束消息转发, 返回NO则进入下一步</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二步, 动态方法解析失败, 则调用这个方法</div><div class="line">// 返回的对象将处理该selector, 返回nil则进入下一步</div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第三步, 在这里返回方法的消息签名</div><div class="line">// 返回YES则进入下一步, 返回nil则结束消息转发</div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;eat&quot;])&#123;</div><div class="line">return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</div><div class="line">&#125; else &#123;</div><div class="line">return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第四步, 最后一次处理该消息的机会</div><div class="line">// 这里处理不了这个invocation就会结束消息转发</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">// 在这我们修改选择子为run</div><div class="line">[anInvocation setSelector:@selector(run)];</div><div class="line">// 让dog去调用该方法</div><div class="line">[anInvocation invokeWithTarget:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>((void(*)(id, SEL))objc_msgSend)((id)dog, @selector(eat));</code>的输出结果为 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-09-04 17:56:53.238 Runtime-实践篇[14037:1063170] 是狗在跑步</div></pre></td></tr></table></figure></p>
<p>demo在这里<br><a href="https://link.jianshu.com/?t=https://github.com/Jerry4me/Runtime-demo" target="_blank" rel="external">Github</a></p>
<ol>
<li>动态添加一个类</li>
<li>打印一个类的所有ivar, property 和 method</li>
<li>给分类增加属性</li>
<li>动态添加方法实现</li>
<li>更换方法调用者</li>
<li>更改特定方法的实现</li>
</ol>
<h2 id="十-归档"><a href="#十-归档" class="headerlink" title="十. 归档"></a>十. 归档</h2><p>涉及方法:<br><code>class_copyIvarList</code> <code>ignoredIvarNames</code> <code>objc_setAssociatedObject</code> <code>objc_getAssociatedObject</code></p>
<p><a href="http://www.jianshu.com/p/3e050ec3b759" target="_blank" rel="external">Objective-C中的Runtime LeeJay</a></p>
<p>五、归档<br>大家都知道在归档的时候，需要先将属性一个一个的归档，然后再将属性一个一个的解档，3-5个属性还好，假如100个怎么办，那不得写累死。有了Runtime，就不用担心这个了，下面就是如何利用Runtime实现自动归档和解档。<br>NSObject+Archive.h文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSObject (Archive)</div><div class="line"></div><div class="line">/**</div><div class="line">*  归档</div><div class="line">*/</div><div class="line">- (void)encode:(NSCoder *)aCoder;</div><div class="line"></div><div class="line">/**</div><div class="line">*  解档</div><div class="line">*/</div><div class="line">- (void)decode:(NSCoder *)aDecoder;</div><div class="line"></div><div class="line">/**</div><div class="line">*  这个数组中的成员变量名将会被忽略：不进行归档</div><div class="line">*/</div><div class="line">@property (nonatomic, strong) NSArray *ignoredIvarNames;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>NSObject+Archive.m文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSObject+Archive.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSObject (Archive)</div><div class="line"></div><div class="line">- (void)encode:(NSCoder *)aCoder</div><div class="line">&#123;</div><div class="line">unsigned int outCount = 0;</div><div class="line">Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">for (unsigned int i = 0; i &lt; outCount; i++)</div><div class="line">&#123;</div><div class="line">Ivar ivar = ivars[i];</div><div class="line">NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">if ([self.ignoredIvarNames containsObject:key])</div><div class="line">&#123;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">id value = [self valueForKey:key];</div><div class="line">[aCoder encodeObject:value forKey:key];</div><div class="line">&#125;</div><div class="line">free(ivars);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)decode:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">unsigned int outCount = 0;</div><div class="line">Ivar *ivars = class_copyIvarList([self class], &amp;outCount);</div><div class="line">for (unsigned int i = 0; i &lt; outCount; i++)</div><div class="line">&#123;</div><div class="line">Ivar ivar = ivars[i];</div><div class="line">NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">if ([self.ignoredIvarNames containsObject:key])</div><div class="line">&#123;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">id value = [aDecoder decodeObjectForKey:key];</div><div class="line">[self setValue:value forKey:key];</div><div class="line">&#125;</div><div class="line">free(ivars);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setIgnoredIvarNames:(NSArray *)ignoredIvarNames</div><div class="line">&#123;</div><div class="line">objc_setAssociatedObject(self,</div><div class="line">@selector(ignoredIvarNames),</div><div class="line">ignoredIvarNames,</div><div class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray *)ignoredIvarNames</div><div class="line">&#123;</div><div class="line">return objc_getAssociatedObject(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后再去需要归档的类实现文件里面写上这几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@implementation Person</div><div class="line"></div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class="line">&#123;</div><div class="line">[self encode:aCoder];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">if (self = [super init])</div><div class="line">&#123;</div><div class="line">[self decode:aDecoder];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这几行代码都是固定写法，你也可以把它们定义成宏，这样就可以实现一行代码就归档了，思路源自MJExtension！</p>
<p><a href="http://blog.csdn.net/deft_mkjing/article/details/53789125" target="_blank" rel="external">Runtime基本知识点以及应用场景 deft_mkjing</a></p>
<p>runtime实现归档和解档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.fish = [NSKeyedUnarchiver unarchiveObjectWithFile:self.path];</div><div class="line">[NSKeyedArchiver archiveRootObject:self.fish toFile:self.path];</div></pre></td></tr></table></figure></p>
<p>当外部调用上面归档解档的代码时会走如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)ignoredNames</div><div class="line">&#123;</div><div class="line">return @[];</div><div class="line">&#125;</div><div class="line">// 解档的时候调用</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">if (self == [super init]) &#123;</div><div class="line">[self mkj_initWithCoder:aDecoder];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">// 归档的时候调用</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class="line">&#123;</div><div class="line">[self mkj_encodeWithCoder:aCoder];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - 普通模式下的归档和解档</div><div class="line">//实现NSCoding协议中的归档方法，需要一个个列出属性来</div><div class="line">//- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</div><div class="line">//    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</div><div class="line">//    [aCoder encodeObject:self.age forKey:@&quot;age&quot;];</div><div class="line">//&#125;</div><div class="line">//</div><div class="line">//</div><div class="line">////实现NSCoding协议中的解档方法</div><div class="line">//- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">//    if (self = [super init]) &#123;</div><div class="line">//        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">//        self.age = [aDecoder decodeObjectForKey:@&quot;age&quot;];</div><div class="line">//    &#125;</div><div class="line">//    return self;</div><div class="line">//&#125;</div><div class="line">- (NSArray *)ignoredProperty</div><div class="line">&#123;</div><div class="line">return @[];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)mkj_encodeWithCoder:(NSCoder *)aCoder</div><div class="line">&#123;</div><div class="line">Class selfClass = self.class;</div><div class="line">while (selfClass &amp;&amp; selfClass != [NSObject class]) &#123;</div><div class="line">unsigned int count = 0;</div><div class="line">Ivar *ivars = class_copyIvarList(selfClass, &amp;count);</div><div class="line">for (NSInteger i = 0; i &lt; count; i ++)</div><div class="line">&#123;</div><div class="line">Ivar ivar = ivars[i];</div><div class="line">const char *ivarName = ivar_getName(ivar);</div><div class="line">NSString *ivarStr = [[NSString stringWithUTF8String:ivarName] substringFromIndex:1];</div><div class="line">if ([self respondsToSelector:@selector(ignoredProperty)]) &#123;</div><div class="line">// 如果归档key为空</div><div class="line">if ([[self ignoredProperty] containsObject:ivarStr]) &#123;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">id value = [self valueForKey:ivarStr];</div><div class="line">[aCoder encodeObject:value forKey:ivarStr];</div><div class="line">&#125;</div><div class="line">free(ivars);</div><div class="line">selfClass = [selfClass superclass];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)mkj_initWithCoder:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">Class selfClass = self.class;</div><div class="line">while (selfClass &amp;&amp; selfClass != [NSObject class]) &#123;</div><div class="line">unsigned int count = 0;</div><div class="line">Ivar *ivars = class_copyIvarList(selfClass, &amp;count);</div><div class="line">for (NSInteger i = 0; i &lt; count; i ++)</div><div class="line">&#123;</div><div class="line">Ivar ivar = ivars[i];</div><div class="line">const char *ivarName = ivar_getName(ivar);</div><div class="line">NSString *ivarStr = [[NSString stringWithUTF8String:ivarName] substringFromIndex:1];</div><div class="line">if ([self respondsToSelector:@selector(ignoredProperty)]) &#123;</div><div class="line">// 如果归档key为空</div><div class="line">if ([[self ignoredProperty] containsObject:ivarStr]) &#123;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">id value = [aDecoder decodeObjectForKey:ivarStr];</div><div class="line">[self setValue:value forKey:ivarStr];</div><div class="line"></div><div class="line">&#125;</div><div class="line">free(ivars);</div><div class="line">selfClass = [selfClass superclass];</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="十一"><a href="#十一" class="headerlink" title="十一"></a>十一</h2><p><a href="http://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">轻松学习之二——iOS利用Runtime自定义控制器POP手势动画 J_雨 </a><br>利用runtime获取系统手势的target和action<br><code>class_copyIvarList</code></p>
<h2 id="十二"><a href="#十二" class="headerlink" title="十二"></a>十二</h2><p><a href="http://www.jianshu.com/p/b3789d4580ac" target="_blank" rel="external">runtime运用 -从一个模型中找出所有属性赋值给另外一个模型 醋溜草莓便当</a></p>
<p><code>objc_property_t</code> <code>class_copyPropertyList</code> <code>property_getName</code></p>
<h2 id="十三"><a href="#十三" class="headerlink" title="十三"></a>十三</h2><p>热修复 JSPatch</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/17/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/17/postName/" rel="prev" title="书签">
                书签 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofutv2nt8.bkt.clouddn.com/blog/image/xiamu.jpeg"
               alt="安国立" />
          <p class="site-author-name" itemprop="name">安国立</p>
          <p class="site-description motion-element" itemprop="description">留给中国队的时间不多了</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-交换方法（method-swizzing）"><span class="nav-number">1.</span> <span class="nav-text">一. 交换方法（method swizzing）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Swizzling通用方法封装"><span class="nav-number">1.1.</span> <span class="nav-text">Method Swizzling通用方法封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例一：替换ViewController生命周期方法"><span class="nav-number">1.2.</span> <span class="nav-text">实例一：替换ViewController生命周期方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例二：解决获取索引、添加、删除元素越界崩溃问题"><span class="nav-number">1.3.</span> <span class="nav-text">实例二：解决获取索引、添加、删除元素越界崩溃问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例三：防止按钮重复暴力点击"><span class="nav-number">1.4.</span> <span class="nav-text">实例三：防止按钮重复暴力点击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例四：全局更换控件初始效果"><span class="nav-number">1.5.</span> <span class="nav-text">实例四：全局更换控件初始效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例六：App异常加载占位图通用类封装（更新于：2016-12-01）"><span class="nav-number">1.6.</span> <span class="nav-text">实例六：App异常加载占位图通用类封装（更新于：2016/12/01）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例七：全局修改导航栏后退（返回）按钮（更新于：2016-12-05）"><span class="nav-number">1.7.</span> <span class="nav-text">实例七：全局修改导航栏后退（返回）按钮（更新于：2016/12/05）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-给分类添加属性"><span class="nav-number">2.</span> <span class="nav-text">二. 给分类添加属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防止按钮重复暴力点击"><span class="nav-number">2.1.</span> <span class="nav-text">防止按钮重复暴力点击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按钮防止被重复点击的方法-iOS"><span class="nav-number">2.2.</span> <span class="nav-text">按钮防止被重复点击的方法 (iOS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-字典转模型"><span class="nav-number">3.</span> <span class="nav-text">三. 字典转模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">3.1.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据字典自动生成属性代码"><span class="nav-number">3.2.</span> <span class="nav-text">根据字典自动生成属性代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-动态添加一个类"><span class="nav-number">4.</span> <span class="nav-text">四. 动态添加一个类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-打印一个类的所有ivar-property-和-method"><span class="nav-number">5.</span> <span class="nav-text">五. 打印一个类的所有ivar, property 和 method</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-动态添加方法"><span class="nav-number">6.</span> <span class="nav-text">六. 动态添加方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态添加方法实现"><span class="nav-number">6.1.</span> <span class="nav-text">动态添加方法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-消息转发"><span class="nav-number">7.</span> <span class="nav-text">七. 消息转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-更换方法调用者"><span class="nav-number">8.</span> <span class="nav-text">八. 更换方法调用者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九-更改特定方法的实现"><span class="nav-number">9.</span> <span class="nav-text">九. 更改特定方法的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十-归档"><span class="nav-number">10.</span> <span class="nav-text">十. 归档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一"><span class="nav-number">11.</span> <span class="nav-text">十一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二"><span class="nav-number">12.</span> <span class="nav-text">十二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三"><span class="nav-number">13.</span> <span class="nav-text">十三</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安国立</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
