<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="多线程," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="多线程多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。
原理：同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）,多线">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://yoursite.com/2017/12/29/multithreading/index.html">
<meta property="og:site_name" content="An Guoli's Blog">
<meta property="og:description" content="多线程多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。
原理：同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）,多线">
<meta property="og:image" content="http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/4%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AF%94%E8%BE%83.png">
<meta property="og:image" content="http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/%E5%90%84%E7%A7%8D%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C.png">
<meta property="og:image" content="http://yoursite.com/2017/12/29/multithreading/1.jpg">
<meta property="og:updated_time" content="2018-01-31T07:48:58.410Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程">
<meta name="twitter:description" content="多线程多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。
原理：同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）,多线">
<meta name="twitter:image" content="http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/4%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AF%94%E8%BE%83.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/29/multithreading/"/>





  <title> 多线程 | An Guoli's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>
<a href="https://github.com/anguoli"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">An Guoli's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/29/multithreading/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="安国立">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofutv2nt8.bkt.clouddn.com/blog/image/xiamu.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="An Guoli's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="An Guoli's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                多线程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-29T11:50:56+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。</p>
<p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p>
<p><strong>原理</strong>：<br>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）,多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）,如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>
<ul>
<li>注意：多线程并发，并不是cpu在同一时刻同时执行多个任务，只是CPU调度足够快，造成的假象。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源利用率（CPU、内存利用率）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>1.开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>2.线程越多，CPU在调度线程上的开销就越大</li>
</ul>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。</p>
<p>作用：</p>
<p>显示\刷新UI界面</p>
<p>处理UI事件（比如点击事件、滚动事件、拖拽事件等）</p>
<p>注意：</p>
<p>刷新UI必须放在主线程</p>
<p>别将比较耗时的操作放到主线程中</p>
<p>耗时操作会卡住主线程，严重影响UI的流畅度</p>
<p>多线程实现方案:<br><img src="http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/4%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AF%94%E8%BE%83.png" alt=""></p>
<blockquote>
<p>面试题: iOS NSThread NSOperation GCD的优缺点</p>
</blockquote>
<p>NSThread、 GCD、 NSOperation 抽象封装度层次从低到高，抽象封装度越高使用越简单。</p>
<p>NSthread:</p>
<p>优点：比其他两种轻量级。</p>
<p>缺点：需要自己管理线程的生命周期，线程同步。 线程同步对数据的加锁会有一定的开销。</p>
<p>用来做调试 一个方法查看代码楚楚的线程</p>
<p>Operation、GCD:</p>
<p>优点：不需要关心线程管理，数据同步的事情。</p>
<p>两者区别：NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。</p>
<p>当需求能够以更简单的底层代码完成的时候，GCD或许是个更好的选择，因为GCD主要与block结合使用，代码简洁高效和集中，维护度比较高。GCD 关注如何在多个 cpu 上提升效率,GCD在追求性能的底层操作来说，是速度最快的。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD更有优势</p>
<p><a href="http://www.jianshu.com/p/2e783677552b" target="_blank" rel="external">原文链接</a></p>
<blockquote>
<p>面试题: NSOperation 相比于 GCD 有哪些优势？</p>
</blockquote>
<p>1.从性能上来说：<br>GCD是底层的C语言构成的API，更接近底层，而NSOperationQueue基于GCD，使用Objective-C实现的面向对象的线程管理，比GCD更高级抽象。所以GCD在追求性能的底层操作来说，是速度最快的。（单纯从性能速度来说，只有Instruments显示有真正的性能提升时才有必要用低级的GCD。）</p>
<p>2.从异步操作之间的事务性，顺序行，依赖关系。GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持<br>对同一个并行队列中的任务操作来说：<br>在NSOperationQueue中，可以随时取消已经设定要准备执行的任务，能够方便地设置依赖关系，能够设置NSOperation的priority优先级，而GCD需要自己写更多的代码来实现。</p>
<p>3.如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperationQueue会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势</p>
<p>4.从复用度来说：<br>能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。<br>NSOperation NSOperation 是一个抽象基类，我们必须使用它的子类。iOS 提供了两种默认实现：NSInvocationOperation 和 NSBlockOperation。</p>
<p><a href="http://www.jianshu.com/p/49b726694247" target="_blank" rel="external">原文链接</a></p>
<blockquote>
<p>面试题: 你的项目什么时候选择使用GCD,什么时候选择NSOperation?</p>
</blockquote>
<p>答:项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会使代码更为易读，建议在简单项目中使用。</p>
<p><a href="http://www.jianshu.com/p/0d2713164646" target="_blank" rel="external">原文链接</a></p>
<blockquote>
<p>面试题: 线程间怎么通信?</p>
</blockquote>
<p>（1）GCD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</div><div class="line">//下载图片</div><div class="line">UIImage *image = nil;</div><div class="line">dispatch_async(dispatch_get_main_queue(),^&#123;</div><div class="line">//回到主线程</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>（2）NSThread的线程通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</div><div class="line">//下载图片</div><div class="line">UIImage *image = nil;</div><div class="line">[self performSelector:@selector(settingImage:) onThread:[NSThread mainThread]withObject:image waitUntilDone:YES modes:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种情况也适用于子线程之间的通信。</p>
<p>在 iOS 中的 4 套多线程方案，他们分别是：</p>
<ul>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation &amp; NSOperationQueue</li>
</ul>
<h2 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h2><p>这是一套在很多操作系统上都通用的多线程API, 基于 c语言 的框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &lt;pthread.h&gt;</div><div class="line"></div><div class="line">// 创建线程，并执行任务</div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    pthread_t thread;</div><div class="line">    //创建一个线程并自动执行</div><div class="line">    pthread_create(&amp;thread, NULL, start, NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void *start(void *data) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2015-07-27 23:57:21.689 testThread[10616:2644653] &lt;NSThread: 0x7fbb48d33690&gt;&#123;number = 2, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>你需要手动处理线程的各个状态的转换即管理生命周期，比如，这段代码虽然创建了一个线程，但并没有销毁。</p>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用，比如 <code>[NSThread currentThread]</code>，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法。</p>
<h3 id="创建并启动"><a href="#创建并启动" class="headerlink" title="创建并启动"></a>创建并启动</h3><ul>
<li>先创建线程类，再启动</li>
</ul>
<p>OBJECTIVE-C</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 创建</div><div class="line"> NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];</div><div class="line"></div><div class="line"> // 启动 线程一启动，就会在线程thread中执行self的run方法</div><div class="line"> [thread start];</div></pre></td></tr></table></figure>
<p>SWIFT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建</div><div class="line">  let thread = NSThread(target: self, selector: &quot;run:&quot;, object: nil)</div><div class="line"></div><div class="line">  //启动</div><div class="line">  thread.start()</div></pre></td></tr></table></figure>
<ul>
<li>创建并自动启动线程</li>
</ul>
<p>OBJECTIVE-C</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];</div></pre></td></tr></table></figure>
<p>SWIFT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSThread.detachNewThreadSelector(&quot;run:&quot;, toTarget: self, withObject: nil)</div></pre></td></tr></table></figure>
<ul>
<li>使用 NSObject 的方法创建(隐式创建)并自动启动线程 </li>
</ul>
<p>OBJECTIVE-C</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self performSelectorInBackground:@selector(run:) withObject:nil];</div></pre></td></tr></table></figure>
<p>SWIFT</p>
<p>苹果认为 performSelector: 不安全，所以在 Swift 去掉了这个方法。<br>Note: The performSelector: method and related selector-invoking methods are not imported in Swift because they are inherently unsafe.</p>
<p>上述2种创建线程方式的优缺点</p>
<ul>
<li>优点：简单快捷</li>
<li>缺点：无法对线程进行更详细的设置</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//取消线程</div><div class="line">- (void)cancel;</div><div class="line"></div><div class="line">//启动线程</div><div class="line">- (void)start;</div><div class="line"></div><div class="line">//判断某个线程的状态的属性</div><div class="line">@property (readonly, getter=isExecuting) BOOL executing;</div><div class="line">@property (readonly, getter=isFinished) BOOL finished;</div><div class="line">@property (readonly, getter=isCancelled) BOOL cancelled;</div><div class="line"></div><div class="line">//设置和获取线程名字</div><div class="line">-(void)setName:(NSString *)n;</div><div class="line">-(NSString *)name;</div><div class="line"></div><div class="line">//获取当前线程信息</div><div class="line">+ (NSThread *)currentThread;</div><div class="line"></div><div class="line">//获取主线程信息</div><div class="line">+ (NSThread *)mainThread;</div><div class="line"></div><div class="line">// 是否为主线程(类方法)</div><div class="line">+ (BOOL)isMainThread;</div><div class="line"></div><div class="line">// 是否为主线程（对象方法）</div><div class="line">- (BOOL)isMainThread;</div><div class="line"></div><div class="line">//使当前线程暂停一段时间，或者暂停到某个时刻</div><div class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)time;</div><div class="line">+ (void)sleepUntilDate:(NSDate *)date;</div><div class="line"></div><div class="line">// 强制停止线程-&gt; 进入死亡状态</div><div class="line">+ (void)exit;</div><div class="line">//注意：一旦线程停止（死亡）了，就不能再次开启任务</div></pre></td></tr></table></figure>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>全称是Grand Central Dispatch，“伟大的中枢调度器”。GCD是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。同时它使用的也是 c语言，提供了非常多强大的函数, 由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。</p>
<h3 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h3><p>GCD中有2个核心概念</p>
<h4 id="任务：执行什么操作"><a href="#任务：执行什么操作" class="headerlink" title="任务：执行什么操作"></a>任务：执行什么操作</h4><ul>
<li><p>即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： <strong>同步执行</strong> 和 <strong>异步执行</strong>，他们之间的区别是 <code>能不能开启新的线程</code>。</p>
<p>同步：只是在当前线程中执行任务，不具备开启新线程的能力</p>
<p>异步：可以在新的线程中执行任务，具备开启新线程的能力</p>
</li>
<li><p>同步在当前线程中执行，任务会立即执行,它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续运行,就是在发出一个功能调用时，在没有得到结果之前，该调用就不继续往下运行(调用)。是一定不会开新线程的,也就是<strong>必须一件一件事做,等前一件做完了才能做下一件事</strong>。（一个线程，当前线程。）;</p>
</li>
<li><p>异步：可以开新线程，可以在新线程内执行任务，并不意味着一定就会开新线程;任务不会立即执行,当前线程会直接往下执行，它不会阻塞当前线程。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的任务在完成后，通过状态、通知和回调来通知调用者。（多个线程，开辟出来的新线程。）;</p>
</li>
<li><p>同步（sync） 和 异步（async） 的主要区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕。</p>
</li>
</ul>
<h4 id="队列：用来存放任务"><a href="#队列：用来存放任务" class="headerlink" title="队列：用来存放任务"></a>队列：用来存放任务</h4><ul>
<li>队列：用来存放任务</li>
<li><p>一共有两种队列， <strong>串行队列</strong> 和 <strong>并行队列</strong></p>
<p>  放到<strong>串行队列</strong>的任务，GCD 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。</p>
<p>  放到并行队列的任务，根据同步或异步有不同的执行方式. GCD 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，GCD 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。有高、默认、低和后台4个优先级。并发功能只有在异步（dispatch_async）函数下才有效.</p>
</li>
</ul>
<p>1、并发队列（Concurrent Dispatch Queue）<br>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（dispatch_async）函数下才有效</p>
<p>2、串行队列（Serial Dispatch Queue）<br>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p>
<pre><code>| 同步执行            | 异步执行
</code></pre><p>——– | —————–  | ———<br>串行队列  | 当前线程，一个一个执行 | 其他线程，一个一个执行<br>并行队列  | 当前线程，一个一个执行 | 开很多线程，一起执行</p>
<pre><code>| 并行队列            | 手动创建串行队列        | 主队列
</code></pre><p>——– | —————–  | ——————– | ————-<br>同步执行  | 当前线程，一个一个执行 | 当前线程，一个一个执行   | 没有开启新线程, 一个一个执行<br>异步执行  | 开很多线程，一起执行   | 其他线程，一个一个执行   | 没有开启新线程, 一个一个执行</p>
<p><img src="http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/%E5%90%84%E7%A7%8D%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C.png" alt=""></p>
<p>GCD使用步骤</p>
<ol>
<li>定制任务:确定想做的事情</li>
<li>将任务添加到队列中:GCD会自动将队列中的任务取出，放到对应的线程中执行。Tips：任务的取出遵循队列的FIFO原则：先进先出，后进后出</li>
</ol>
<h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>  queue:队列</p>
<p>  block:任务</p>
<ul>
<li>同步任务： 会阻塞当前线程 (SYNC)，不具备开启新线程的能力<br><code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// OBJECTIVE-C</div><div class="line">  dispatch_sync(&lt;#queue#&gt;, ^&#123;</div><div class="line">      //code here</div><div class="line">      NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">// SWIFT</div><div class="line">  dispatch_sync(&lt;#queue#&gt;, &#123; () -&gt; Void in</div><div class="line">      //code here</div><div class="line">      println(NSThread.currentThread())</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<ul>
<li>异步任务：不会阻塞当前线程 (ASYNC)，具备开启新线程的能力<br><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">OBJECTIVE-C</div><div class="line">  dispatch_async(&lt;#queue#&gt;, ^&#123;</div><div class="line">      //code here</div><div class="line">      NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">SWIFT</div><div class="line">  dispatch_async(&lt;#queue#&gt;, &#123; () -&gt; Void in</div><div class="line">      //code here</div><div class="line">      println(NSThread.currentThread())</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>GCD中还有个用来执行任务的函数(栅栏-dispatch_barrier) 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行, 后面会讲到</p>
<h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><ul>
<li><p>1、使用dispatch_get_main_queue()获取主队列</p>
<p>  <strong>主队列</strong>：（跟主线程相关联的队列）是GCD自带的一种特殊的 串行队列。放在主队列中的任务，都会放到主线程中执行。任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> //OBJECTIVE-C</div><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line">//SWIFT</div><div class="line">let queue = dispatch_get_main_queue()</div></pre></td></tr></table></figure>
<p>特点：<br>a、主队列是与主线程相关联的队列<br>b、主队列是GCD自带的一种特殊的串行队列<br>c、放在主队列中的任务，都会放到主线程中执行</p>
<ul>
<li>2、使用dispatch_queue_create函数创建队列 (串行队列, 并行队列)</li>
</ul>
<p>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)</p>
<p>label：队列名称</p>
<p>attr:队列属性</p>
<p>DISPATCH_QUEUE_SERIAL 或NULL:串行队列</p>
<p>DISPATCH_QUEUE_CONCURRENT:并发队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//OBJECTIVE-C</div><div class="line">  //串行队列</div><div class="line">  dispatch_queue_t queue = dispatch_queue_create(&quot;serial_queue&quot;, NULL);</div><div class="line">  dispatch_queue_t queue = dispatch_queue_create(&quot;serial_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">  //并行队列</div><div class="line">  dispatch_queue_t queue = dispatch_queue_create(&quot;concurrent.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">  //SWIFT</div><div class="line">  //串行队列</div><div class="line">  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, nil);</div><div class="line">  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL)</div><div class="line">  //并行队列</div><div class="line">  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT)</div></pre></td></tr></table></figure>
<ul>
<li>3、使用dispatch_get_global_queue获取全局并发队列</li>
</ul>
<p>dispatch_get_global_queue(long identifier, unsigned long flags);<br>identifier: 队列的优先级<br>flags:此参数暂时无用，用0即可<br>全局并发队列的优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">//SWIFT</div><div class="line">let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</div></pre></td></tr></table></figure>
<p>特点:GCD默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建</p>
<p>内存管理补充：<br>如果你部署的最低目标低于 iOS 6.0 or Mac OS X 10.8<br>你应该自己管理GCD对象,使用(dispatch_retain,dispatch_release),ARC并不会去管理它们<br>如果你部署的最低目标是 iOS 6.0 or Mac OS X 10.8 或者更高的<br>ARC已经能够管理GCD对象了,这时候,GCD对象就如同普通的OC对象一样,不应该使用dispatch_retain or dispatch_release</p>
<p><strong>栅栏-dispatch_barrier</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Swift</div><div class="line">func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</div><div class="line">OC: </div><div class="line">dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>这个方法重点是你传入的 queue，当你传入的 queue 是通过 <code>DISPATCH_QUEUE_CONCURRENT</code> 参数自己创建的 queue 时，这个方法会阻塞这个 queue（<strong>注意是阻塞 queue ，而不是阻塞当前线程</strong>），一直等到这个 queue 中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue 中排在它后面的任务继续执行。</p>
<p>如果你传入的是其他的 queue, 那么它就和 dispatch_async 一样了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</div></pre></td></tr></table></figure>
<p>这个方法的使用和上一个一样，传入 自定义的并发队列 <code>DISPATCH_QUEUE_CONCURRENT</code>，它和上一个方法一样的阻塞 queue，不同的是 这个方法还会 <strong>阻塞当前线程</strong>。<br>如果你传入的是其他的 queue, 那么它就和 dispatch_sync 一样了。</p>
<p><strong>特别注意：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列 (线程卡死)</strong></p>
<p>4个术语比较容易混淆：同步、异步、并发、串行</p>
<p>1.同步和异步主要影响：能不能开启新的线程</p>
<p>同步：只是在当前线程中执行任务，不具备开启新线程的能力</p>
<p>异步：可以在新的线程中执行任务，具备开启新线程的能力</p>
<p>2.并发和串行主要影响：任务的执行方式</p>
<p>并发：多个任务并发（同时）执行</p>
<p>串行：一个任务执行完毕后，再执行下一个任务</p>
<h3 id="GCD运用"><a href="#GCD运用" class="headerlink" title="GCD运用"></a>GCD运用</h3><p>一、线程间通信</p>
<p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信<br>例如在子线程下载图片，在主线程刷新UI显示图片。</p>
<p>1、调用NSObject的方法</p>
<ul>
<li><p>在主线程上执行操作<br><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</code></p>
</li>
<li><p>在指定线程上执行操作<br><code>- (void)performSelector:(SEL)aSelector onThread:(NSThread*)thr withObject:(id)arg waitUnti</code></p>
</li>
</ul>
<p>2、GCD方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//从子线程回到主线程</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</div><div class="line">        // 执行耗时的异步操作...</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            // 回到主线程，执行UI刷新操作&#125;);</div><div class="line">            </div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>二、延时执行</p>
<p>iOS常见的延时执行有2种方式</p>
<p>1、调用NSObject的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</div><div class="line">// 2秒后调用self的run方法</div></pre></td></tr></table></figure>
<p>2、使用GCD函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">延迟执行, 这段代码将会在2秒后将任务插入RunLoop当中</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW,(int64_t)(2.0* NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">// 2秒后异步执行这里的代码...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>三、一次性代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</div><div class="line">单例的时候会使用到，避免返回的对象不是同一个对象</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">// 只执行1次的代码(这里面默认是线程安全的)：不会有其他线程可以访问到这里</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>单例模式</strong></p>
<p>作用：<br>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问。从而方便地控制了实例个数，并节约系统资源</p>
<p>使用场合:<br>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static HLUserManager *_singleton = nil;</div><div class="line">@implementation HLUserManager</div><div class="line"></div><div class="line">+ (instancetype)sharedManager &#123;</div><div class="line">    </div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _singleton = [[HLUserManager alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return _singleton;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>四、快速迭代</p>
<p>dispatch_apply类似一个for循环，并发的执行每一项。所有任务结束后，dispatch_apply才会返回，会阻塞当前线程。如果传入队列是串行队列，要注意防止死锁现象的发生。<br>循环执行任务，任务的顺序是无序列的并且会堵塞当前的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 使用dispatch_apply函数能进行快速迭代遍历</div><div class="line">// 第一个参数: 迭代次数，第二个参数: 线程队列(并发队列) ，第三个参数: index 索引 block: 任务</div><div class="line">dispatch_apply(10, dispatch_get_global_queue(0,0), ^(size_t index)&#123;</div><div class="line">    // 执行10次代码，index顺序不确定</div><div class="line">           NSLog(@&quot;GCD- %zd -- %@&quot;, index, [NSThread currentThread]); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>五、队列组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</div><div class="line"> // 1.实例化一个调度组</div><div class="line"> dispatch_group_t group = dispatch_group_create();</div><div class="line"> // 2.获取一个全局队列</div><div class="line"> dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"> // 3.把任务添加进队列中</div><div class="line"></div><div class="line"> dispatch_group_async(group, queue, ^&#123;</div><div class="line">     // 执行1个耗时的异步操作</div><div class="line">     </div><div class="line"> &#125;);</div><div class="line"> dispatch_group_async(group, queue, ^&#123;</div><div class="line">     // 执行1个耗时的异步操作</div><div class="line">     </div><div class="line"> &#125;);</div><div class="line">    // 4.获得所有调度任务都完成后的通知 </div><div class="line"> dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">     // 等前面的异步操作都执行完毕后，回到主线程...</div><div class="line">            NSLog(@&quot;更新UI&quot;);</div><div class="line"> </div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>手动管理group关联的block的运行状态（或计数），进入和退出group次数必须匹配</p>
<p>dispatch_group_enter(group);</p>
<p>dispatch_group_leave(group);</p>
<p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。下面是使用方法，这是一个很实用的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">SWIFT</div><div class="line">//1.创建队列组</div><div class="line">let group = dispatch_group_create()</div><div class="line">//2.创建队列</div><div class="line">let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</div><div class="line"></div><div class="line">//3.多次使用队列组的方法执行任务, 只有异步方法</div><div class="line">//3.1.执行3次循环</div><div class="line">dispatch_group_async(group, queue) &#123; () -&gt; Void in</div><div class="line">    for _ in 0..&lt;3 &#123;</div><div class="line">        NSLog(&quot;group-01 - %@&quot;, NSThread.currentThread())</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3.2.主队列执行8次循环</div><div class="line">dispatch_group_async(group, dispatch_get_main_queue()) &#123; () -&gt; Void in</div><div class="line">    for _ in 0..&lt;8 &#123;</div><div class="line">        NSLog(&quot;group-02 - %@&quot;, NSThread.currentThread())</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3.3.执行5次循环</div><div class="line">dispatch_group_async(group, queue) &#123; () -&gt; Void in</div><div class="line">    for _ in 0..&lt;5 &#123;</div><div class="line">        NSLog(&quot;group-03 - %@&quot;, NSThread.currentThread())</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//4.都完成后会自动通知</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue()) &#123; () -&gt; Void in</div><div class="line">    NSLog(&quot;完成 - %@&quot;, NSThread.currentThread())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2015-07-28 03:40:34.277 test[12540:3319271] group-03 - &lt;NSThread: 0x7f9772536f00&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.277 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.277 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.277 test[12540:3319271] group-03 - &lt;NSThread: 0x7f9772536f00&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319271] group-03 - &lt;NSThread: 0x7f9772536f00&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319271] group-03 - &lt;NSThread: 0x7f9772536f00&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.277 test[12540:3319273] group-01 - &lt;NSThread: 0x7f977272e8d0&gt;&#123;number = 2, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319271] group-03 - &lt;NSThread: 0x7f9772536f00&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319273] group-01 - &lt;NSThread: 0x7f977272e8d0&gt;&#123;number = 2, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.278 test[12540:3319273] group-01 - &lt;NSThread: 0x7f977272e8d0&gt;&#123;number = 2, name = (null)&#125;</div><div class="line">2015-07-28 03:40:34.279 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.279 test[12540:3319146] group-02 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-28 03:40:34.279 test[12540:3319146] 完成 - &lt;NSThread: 0x7f977240ba60&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>六、GCD 计时器应用</p>
<p>NSTimer 的定时器是在 RunLoop 中实现的，由于RunLoop在处理各种任务，所以会造成计时器不够准确，有时候会相对慢一些，有没有什么方法会让计时变得准确？有，使用 GCD 的计时器方法会让计时器变得相对准确，而且GCD不受RunLoop的 Mode 影响。</p>
<p>我们需要做的是，选择其队列类型，这里我选择的是全局队列。</p>
<p>dispatch Queue :决定了将来回调的方法在哪里执行。</p>
<p>dispatch_source_set_timer 方法:<br>// dispatch_source_t timer 第一个参数: 是一个OC对象</p>
<p>// DISPATCH_TIME_NOW 第二个参数：定时器开始时间,也可以使用如下的方法，在Now 的时间基础上再延时多长时间执行以下任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> dispatch_time(&lt;#dispatch_time_t when#&gt;, &lt;#int64_t delta#&gt;)</div><div class="line"> </div><div class="line"> dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, 0 * NSEC_PER_SEC);</div><div class="line">//    dispatch_time_t start = dispatch_walltime(NULL, 0);</div></pre></td></tr></table></figure>
<p>// intervalInSeconds 第三个参数:定时器开始后的间隔时间（纳秒 NSEC_PER_SEC）</p>
<p>// leewayInSeconds 第四个参数：间隔精准度，0代标最精准，传入一个大于0的数，代表多少秒的范围是可以接收的,主要为了提高程序性能，积攒一定的时间，Runloop执行完任务会睡觉，这个方法让他多睡一会，积攒时间，任务也就相应多了一点，而后一起执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> // 全局队列</div><div class="line">dispatch_queue_t  queue = dispatch_get_global_queue(0, 0);</div><div class="line">// 创建一个 timer 类型定时器 （ DISPATCH_SOURCE_TYPE_TIMER）</div><div class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">//设置定时器的各种属性（何时开始，间隔多久执行）</div><div class="line">// GCD 的时间参数一般为纳秒 （1 秒 = 10 的 9 次方 纳秒）</div><div class="line">// 指定定时器开始的时间和间隔的时间</div><div class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0);</div><div class="line">// 任务回调</div><div class="line">dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">    NSLog(@&quot;-----定时器-------&quot;);</div><div class="line">&#125;);</div><div class="line">// 开始定时器任务（定时器默认开始是暂停的，需要复位开启）</div><div class="line">dispatch_resume(timer);</div></pre></td></tr></table></figure>
<p>开始定时器</p>
<p>dispatch_resume(self.timer);</p>
<p>暂停定时器</p>
<p>dispatch_suspend(self.timer);</p>
<p>取消定时器</p>
<p>dispatch_cancel(self.timer);<br>self.timer = nil;</p>
<p>GCD实现验证码倒计时按钮案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 开启倒计时效果</div><div class="line">(IBAction)openCountdown:(id)sender &#123;</div><div class="line">    __block NSInteger time = 59; //倒计时时间</div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line"> dispatch_source_set_timer(timer,DISPATCH_TIME_NOW,1.0*NSEC_PER_SEC, 0); //每秒执行</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">        if(time &lt;= 0)&#123; //倒计时结束，关闭</div><div class="line">            dispatch_source_cancel(timer);</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                //设置按钮的样式</div><div class="line">                [self.openSeconds setTitle:@&quot;重新发送&quot; forState:UIControlStateNormal];</div><div class="line">                self.timeLabel.text = @&quot;开始&quot;;</div><div class="line">                self.openSeconds.userInteractionEnabled = YES;</div><div class="line">            &#125;);</div><div class="line">        &#125;else&#123;</div><div class="line">            int seconds = time % 60;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                //设置label读秒效果</div><div class="line">                self.timeLabel.text = [NSString stringWithFormat:@&quot;重新发送(%.2d)&quot;,seconds];</div><div class="line">                [self.openSeconds setTitle:@&quot;已发送&quot; forState:UIControlStateNormal];</div><div class="line">              // 在这个状态下 用户交互关闭，防止再次点击 button 再次计时</div><div class="line">                self.openSeconds.userInteractionEnabled = NO;</div><div class="line">            &#125;);</div><div class="line">            time--;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    dispatch_resume(timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>七、栅栏-dispatch_barrier</p>
<p>需求点：虽然我们有时要执行几个不同的异步任务，但是我们还是要将其分成两组：当第一组异步任务都执行完成后才执行第二组的异步任务。这里的组可以包含一个任务，也可以包含多个任务。<br>为了实现这个需求，我们需要使用dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);<br>在两组任务之间形成“栅栏”，使其“下方”的异步任务在其“上方”的异步任务都完成之前是无法执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    NSLog(@&quot;----任务 1-----&quot;); &#125;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    NSLog(@&quot;----任务 2-----&quot;); &#125;);</div><div class="line"></div><div class="line">dispatch_barrier_async(queue, ^&#123;</div><div class="line">    NSLog(@&quot;----barrier-----&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    NSLog(@&quot;----任务 3-----&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    NSLog(@&quot;----任务 4-----&quot;); &#125;);</div></pre></td></tr></table></figure>
<p>为了更好的理解同步和异步，和各种队列的使用，下面看两个示例:</p>
<blockquote>
<p>面试题: 以下代码在主线程调用，结果是什么？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSLog(&quot;之前 - %@&quot;, NSThread.currentThread())</div><div class="line">dispatch_sync(dispatch_get_main_queue(), &#123; () -&gt; Void in </div><div class="line">        NSLog(&quot;sync - %@&quot;, NSThread.currentThread())</div><div class="line">&#125;)</div><div class="line">NSLog(&quot;之后 - %@&quot;, NSThread.currentThread())</div></pre></td></tr></table></figure>
<p><strong>答案</strong>：</p>
<p>只会打印第一句：<code>之前 - &lt;NSThread: 0x7fb3a9e16470&gt;{number = 1, name = main}</code> ，然后主线程就卡死了，你可以在界面上放一个按钮，你就会发现点不了了。</p>
<p><strong>解释</strong>：</p>
<p>同步任务会阻塞当前线程，然后把 Block 中的任务放到指定的队列中执行，只有等到 Block 中的任务完成后才会让当前线程继续往下运行。</p>
<p>那么这里的步骤就是：打印完第一句后，dispatch_sync 立即阻塞当前的主线程，然后把 Block 中的任务放到 main_queue 中，可是 main_queue 中的任务会被取出来放到主线程中执行，但主线程这个时候已经被阻塞了，所以 Block 中的任务就不能完成，它不完成，dispatch_sync 就会一直阻塞主线程，这就是死锁现象。导致主线程一直卡死。</p>
<blockquote>
<p>面试题: 以下代码会产生什么结果？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL)</div><div class="line"></div><div class="line">NSLog(&quot;之前 - %@&quot;, NSThread.currentThread())</div><div class="line"></div><div class="line">dispatch_async(queue, &#123; () -&gt; Void in</div><div class="line">    NSLog(&quot;sync之前 - %@&quot;, NSThread.currentThread())</div><div class="line">    dispatch_sync(queue, &#123; () -&gt; Void in</div><div class="line">         NSLog(&quot;sync - %@&quot;, NSThread.currentThread())</div><div class="line">    &#125;)</div><div class="line">    NSLog(&quot;sync之后 - %@&quot;, NSThread.currentThread())</div><div class="line">&#125;)</div><div class="line"></div><div class="line">NSLog(&quot;之后 - %@&quot;, NSThread.currentThread())</div></pre></td></tr></table></figure>
<p><strong>答案：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2015-07-30 02:06:51.058 test[33329:8793087] 之前 - &lt;NSThread: 0x7fe32050dbb0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2015-07-30 02:06:51.059 test[33329:8793356] sync之前 - &lt;NSThread: 0x7fe32062e9f0&gt;&#123;number = 2, name = (null)&#125;</div><div class="line">2015-07-30 02:06:51.059 test[33329:8793087] 之后 - &lt;NSThread: 0x7fe32050dbb0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>很明显 <code>sync - %@</code> 和 <code>sync之后 - %@</code> 没有被打印出来！这是为什么呢？我们再来分析一下：</p>
<p><strong>分析：</strong></p>
<p>我们按执行顺序一步步来哦：</p>
<ol>
<li>使用 <code>DISPATCH_QUEUE_SERIAL</code> 这个参数，创建了一个 <strong>串行队列</strong>。</li>
<li>打印出 <code>之前 - %@</code> 这句。</li>
<li><code>dispatch_async</code> 异步执行，所以当前线程不会被阻塞，于是有了两条线程，一条当前线程继续往下打印出 <code>之后 - %@</code>这句, 另一台执行 Block 中的内容打印 <code>sync之前 - %@</code> 这句。因为这两条是并行的，所以打印的先后顺序无所谓。</li>
<li><p>注意，高潮来了。现在的情况和上一个例子一样了。<code>dispatch_sync</code>同步执行，于是它所在的线程会被阻塞，一直等到 <code>sync</code> 里的任务执行完才会继续往下。于是 <code>sync</code> 就高兴的把自己 Block 中的任务放到 <code>queue</code> 中，可谁想 <code>queue</code> 是一个串行队列，一次执行一个任务，所以 <code>sync</code> 的 Block 必须等到前一个任务执行完毕，可万万没想到的是 <code>queue</code> 正在执行的任务就是被 <code>sync</code> 阻塞了的那个。于是又发生了死锁。所以 <code>sync</code> 所在的线程被卡死了。剩下的两句代码自然不会打印。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### GCD总结</div><div class="line"></div><div class="line">* 同步异步函数的作用：将任务添加到队列中</div><div class="line">* 队列作用：决定任务执行的顺序，先添加的先执行，最后添加的任务最后执行</div><div class="line">* 同步函数：堵塞当前线程；需要等待任务结束才能返回；在当前线程中进行；无开辟线程的权限</div><div class="line">* 异步函数：不会堵塞当前线程；不需要等待任务；有开辟线程的权限</div><div class="line">* 队列和任务关系；任务放在队列里</div><div class="line">* 任务跟线程关系：任务需要线程来执行；</div><div class="line">* 线程跟队列关系：一个队列里可能有好多线程，在一个线程内可能也有多个队列；在某个线程里创建队列，那么这个队列是属于这个线程的；</div><div class="line">* 主队列和主线程的关系：主队列是主线中的一个串行队列。所有的和UI的操作(刷新或者点击按钮)都必须在主线程中的主队列中去执行，否则无法更新UI，每一个应用程序只有唯一的一个主队列用来update UI。如果在主线里创建了一个自定义的队列，那么这个队列也就属于主线程的队列。</div><div class="line">* 注意重点：如果在主线程里创建了一个自定义的队列，且如果主线程在主队列中被堵塞了，那么主线程会跑到这个自定义队列里看看有没有任务，如果有就执行。</div><div class="line">* 如果在主线程中创建自定义队列(串行或者并行均可),在这个队列中执行同步任务，同样可以更新UI操作，主队列中可以更新UI，自定义队列也可以更新UI，但自定义队列的更新UI的前提是在主线程中执行同步任务</div><div class="line"></div><div class="line">&gt; 面试题: **同步主队列死锁原因**：</div><div class="line"></div><div class="line">&gt; 在主线程里，开启同步任务，并打算使用主队列，当开始执行同步函数的时候，这时候发生了什么：</div><div class="line"></div><div class="line">1. 主队列会把同步函数任务放到主队列的最前面也就是最先执行的地方</div><div class="line">2. 同步函数堵塞当前的线程也就是主线程，并把block中的任务添加到主队列，这时候block中的任务跟同步任务都在同一个线程、同一个队列，block中的任务排在同步任务的后面，等待前面任务（同步任务）的执行。</div><div class="line">3. 同步函数的特点是必须等待block中的任务执行完才能返回，但是同步任务和block中的任务都在主队列里，根据先进先执行（FIFO）的原则，会发生这样的无限循环现象：同步任务等待block任务执行完，但是同步任务又排在了block任务的前面，block任务不能执行，那就等于同步任务也不能执行完成，所以产生死锁现象。</div><div class="line"></div><div class="line">&gt; 面试题: **同步串行队列不会发生死锁原因**：</div><div class="line"></div><div class="line">&gt; 在主线程里，开启同步任务，并自定义串行队列，当开始执行同步函数的时候，这时候发生了什么：</div><div class="line"></div><div class="line">1. 主队列会把同步函数任务放到主队列的最前面也就是最先执行的地方</div><div class="line">2. 同步函数堵塞当前的线程也就是主线程，并把block中的任务添加到自定义串行队列，这时候，在主线程也就有了两个队列，block中的任务跟同步任务都在同一个线程，但是不在同一个队列。</div><div class="line">3. 主线程在主队列被同步函数堵塞，会跑到它的其他队列里，看看有没有要执行的任务。所以它会去自定义队列里去执行任务。</div><div class="line">4. 同步函数的特点是必须等待block中的任务执行完才能返回，自定义队列里的任务已被执行完，同步函数也就执行完返回主线程。</div><div class="line"></div><div class="line">**重点：虽然主队列中的主线程被堵塞了，但是主线程可以去执行其他属于主线程的队列的任务。**</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">[原文链接](https://www.jianshu.com/p/ddbb152bfbd8)</div><div class="line"></div><div class="line"></div><div class="line">## NSOperation和NSOperationQueue</div><div class="line"></div><div class="line"></div><div class="line">NSOperation是苹果封装的一套多线程的东西，不像GCD是纯C语言的，这个是OC的。但相比较之下GCD会更快一些，但本质上NSOPeration是对GDC的封装。</div><div class="line"></div><div class="line">### NSOperation相对于GCD：</div><div class="line"></div><div class="line">NSOperation拥有更多的函数可用</div><div class="line"></div><div class="line">NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。</div><div class="line"></div><div class="line">NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）</div><div class="line"></div><div class="line">GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序</div><div class="line"></div><div class="line"></div><div class="line">### NSOperation剖析</div><div class="line"></div><div class="line">NSOperation是个抽象类，并不具备封装任务的能力，必须使用它的子类来封装任务</div><div class="line">使用NSOperation子类的方式有3种:</div><div class="line"></div><div class="line">- NSInvocationOperation</div><div class="line">- NSBlockOperation</div><div class="line">- 自定义子类继承NSOperation，实现内部相应的方法</div><div class="line"></div><div class="line">创建一个 Operation 后，需要调用 `start` 方法来启动任务，它会 **默认在当前线程同步执行** 。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</div><div class="line"></div><div class="line">NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 `NSOperation` 和 `NSOperationQueue`  分别对应 GCD 的 `任务` 和 `队列` 。操作步骤也很好理解：</div><div class="line"></div><div class="line">1. 将要执行的任务封装到一个 NSOperation 对象中。</div><div class="line">2. 将NSOperation对象添加到一个 NSOperationQueue 对象中。</div><div class="line">3. 系统会自动将NSOperationQueue中的NSOperation取出来放到一条新线程中执行</div><div class="line"></div><div class="line">然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</div><div class="line"></div><div class="line"></div><div class="line">### 添加任务</div><div class="line"></div><div class="line">* **NSInvocationOperation** : 需要传入一个方法名。</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure>
<p>//1.创建NSInvocationOperation对象<br>NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</p>
<p>//2.开始执行<br>[operation start];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div><div class="line"></div><div class="line">在 Swift 构建的和谐社会里，是容不下 NSInvocationOperation 这种不是类型安全的败类的。苹果如是说。 [这里有相关解释](http://stackoverflow.com/questions/26644477/nsinvocationoperation-is-unavailable-in-xcode-6-1)</div><div class="line"></div><div class="line">**注意**：</div><div class="line"></div><div class="line">默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是 **在当前线程同步执行操作** 。</div><div class="line">只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作</div><div class="line"></div><div class="line">* **NSBlockOperation**</div></pre></td></tr></table></figure>
</li>
</ol>
<p>// 1.创建NSBlockOperation对象</p>
<ul>
<li>(id)blockOperationWithBlock:(void(^)(void))block;<br>// 2.通过addExecutionBlock:方法添加更多的操作</li>
</ul>
<ul>
<li><p>(void)addExecutionBlock:(void(^)(void))block;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure>
<p>//1.创建NSBlockOperation对象<br>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;%@&quot;, [NSThread currentThread]);
</code></pre><p>}];</p>
<p>//2.开始任务<br>[operation start];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure>
<p>//1.创建NSBlockOperation对象<br>let operation = NSBlockOperation { () -&gt; Void in</p>
<pre><code>println(NSThread.currentThread())
</code></pre><p>}</p>
<p>//2.开始任务<br>operation.start()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">之前说过这样的任务，默认会在当前线程执行。但是 `NSBlockOperation` 还有一个方法：`addExecutionBlock:` ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 **会并发执行** ，它会 **在主线程和其它的多个线程** 执行这些任务，注意下面的打印结果：</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure>
<pre><code>//1.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}];

//添加多个Block
for (NSInteger i = 0; i &lt; 5; i++) {
    [operation addExecutionBlock:^{
        NSLog(@&quot;第%ld次：%@&quot;, i, [NSThread currentThread]);
    }];
}

//2.开始任务
[operation start];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure>
<pre><code>//1.创建NSBlockOperation对象
let operation = NSBlockOperation { () -&gt; Void in
    NSLog(&quot;%@&quot;, NSThread.currentThread())
}

//2.添加多个Block
for i in 0..&lt;5 {
    operation.addExecutionBlock { () -&gt; Void in
        NSLog(&quot;第%ld次 - %@&quot;, i, NSThread.currentThread())
    }
}

//2.开始任务
operation.start()
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">打印输出</div></pre></td></tr></table></figure>
</li>
</ul>
<p>2015-07-28 17:50:16.585 test[17527:4095467] 第2次 - <nsthread: 0x7ff5c9701910="">{number = 1, name = main}<br>2015-07-28 17:50:16.585 test[17527:4095666] 第1次 - <nsthread: 0x7ff5c972caf0="">{number = 4, name = (null)}<br>2015-07-28 17:50:16.585 test[17527:4095665] <nsthread: 0x7ff5c961b610="">{number = 3, name = (null)}<br>2015-07-28 17:50:16.585 test[17527:4095662] 第0次 - <nsthread: 0x7ff5c948d310="">{number = 2, name = (null)}<br>2015-07-28 17:50:16.586 test[17527:4095666] 第3次 - <nsthread: 0x7ff5c972caf0="">{number = 4, name = (null)}<br>2015-07-28 17:50:16.586 test[17527:4095467] 第4次 - <nsthread: 0x7ff5c9701910="">{number = 1, name = main}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">**NOTE**：`addExecutionBlock` 方法必须在 `start()` 方法之前执行，否则就会报错：</div><div class="line">`‘*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added after the operation has started executing or finished&apos;`</div><div class="line"></div><div class="line">**NOTE**：大家可能发现了一个问题，为什么我在 Swift 里打印输出使用 `NSLog()` 而不是 `println()` 呢？原因是使用 `print() / println()` 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。它会把需要输出的每个字符一个一个的输出到控制台。普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 `println()` 同时打印，就会导致控制台上的字符混乱的堆在一起，而`NSLog()` 就没有这个问题。到底是什么样子的呢？你可以把上面 `NSLog()` 改为 `println()` ，然后一试便知。 [更多 NSLog() 与 println() 的区别看这里](http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog)</div><div class="line"></div><div class="line">* 自定义Operation</div><div class="line"></div><div class="line">除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 `NSOperation` 类，并实现其 `main()` 方法，因为在调用 `start(`) 方法的时候，内部会调用 `main()` 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 `cancel()` 在内的各种方法。</div><div class="line"></div><div class="line">**注意**：</div><div class="line"></div><div class="line">自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）</div><div class="line"></div><div class="line">经常通过`-(BOOL)isCancelled`方法检测操作是否被取消，对取消做出响应。</div><div class="line"></div><div class="line">### 创建队列</div><div class="line"></div><div class="line">看过上面的内容就知道，我们可以调用一个 `NSOperation` 对象的 `start()` 方法来启动这个任务，但是这样做他们默认是 **同步执行** 的。就算是 `addExecutionBlock` 方法，也会在 **当前线程和其他线程** 中执行，也就是说还是会占用当前线程。这时就要用到队列 `NSOperationQueue` 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。**只要添加到队列，会自动调用任务的 start() 方法**</div><div class="line"></div><div class="line"></div><div class="line">- **主队列**</div><div class="line"></div><div class="line">细心的同学就会发现，每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<p>NSOperationQueue *queue = [NSOperationQueue mainQueue];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure></p>
<p>let queue = NSOperationQueue.mainQueue()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- **其他队列**</div><div class="line"></div><div class="line">因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</div><div class="line"></div><div class="line">1. NSOperation可以调用start方法来执行任务，但默认是同步执行的</div><div class="line">2. 如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作</div></pre></td></tr></table></figure></p>
<p>// 添加操作到NSOperationQueue中</p>
<ul>
<li>(void)addOperation:(NSOperation*)op;</li>
<li>(void)addOperationWithBlock:(void(^)(void))block;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意：其他队列的任务会在其他线程并行执行。</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure>
</li>
</ul>
<p>//1.创建一个其他队列<br>NSOperationQueue *queue = [[NSOperationQueue alloc] init];</p>
<p>//2.创建NSBlockOperation对象<br>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”%@”, [NSThread currentThread]);<br>}];</p>
<p>//3.添加多个Block<br>for (NSInteger i = 0; i &lt; 5; i++) {<br>    [operation addExecutionBlock:^{<br>        NSLog(@”第%ld次：%@”, i, [NSThread currentThread]);<br>    }];<br>}</p>
<p>//4.队列添加任务<br>[queue addOperation:operation];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure></p>
<p>//1.创建其他队列<br>let queue = NSOperationQueue()</p>
<p>//2.创建NSBlockOperation对象<br>let operation = NSBlockOperation { () -&gt; Void in<br>    NSLog(“%@”, NSThread.currentThread())<br>}</p>
<p>//3.添加多个Block<br>for i in 0..<5 {="" operation.addexecutionblock="" ()="" -=""> Void in<br>        NSLog(“第%ld次 - %@”, i, NSThread.currentThread())<br>    }<br>}</5></p>
<p>//4.队列添加任务<br>queue.addOperation(operation)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">打印输出</div></pre></td></tr></table></figure></p>
<p>2015-07-28 20:26:28.463 test[18622:4443534] <nsthread: 0x7fd022c3ac10="">{number = 5, name = (null)}<br>2015-07-28 20:26:28.463 test[18622:4443536] 第2次 - <nsthread: 0x7fd022e36d50="">{number = 2, name = (null)}<br>2015-07-28 20:26:28.463 test[18622:4443535] 第0次 - <nsthread: 0x7fd022f237f0="">{number = 4, name = (null)}<br>2015-07-28 20:26:28.463 test[18622:4443533] 第1次 - <nsthread: 0x7fd022d372b0="">{number = 3, name = (null)}<br>2015-07-28 20:26:28.463 test[18622:4443534] 第3次 - <nsthread: 0x7fd022c3ac10="">{number = 5, name = (null)}<br>2015-07-28 20:26:28.463 test[18622:4443536] 第4次 - <nsthread: 0x7fd022e36d50="">{number = 2, name = (null)}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">OK, 这时应该发问了，大家将 `NSOperationQueue` 与 `GCD的队列` 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</div><div class="line"></div><div class="line">这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。`NSOperationQueue` 有一个参数 `maxConcurrentOperationCount` 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛！</div><div class="line"></div><div class="line">`NSOperationQueue` 还有一个添加任务的方法，`- (void)addOperationWithBlock:(void (^)(void))block;` ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</div><div class="line"></div><div class="line">`NSOperation` 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
<p>//1.任务一：下载图片<br>NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”下载图片 - %@”, [NSThread currentThread]);<br>    [NSThread sleepForTimeInterval:1.0];<br>}];</p>
<p>//2.任务二：打水印<br>NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”打水印   - %@”, [NSThread currentThread]);<br>    [NSThread sleepForTimeInterval:1.0];<br>}];</p>
<p>//3.任务三：上传图片<br>NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”上传图片 - %@”, [NSThread currentThread]);<br>    [NSThread sleepForTimeInterval:1.0];<br>}];</p>
<p>//4.设置依赖<br>[operation2 addDependency:operation1];      //任务二依赖任务一<br>[operation3 addDependency:operation2];      //任务三依赖任务二</p>
<p>//5.创建队列并加入任务<br>NSOperationQueue *queue = [[NSOperationQueue alloc] init];<br>[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure></p>
<p>//1.任务一：下载图片<br>let operation1 = NSBlockOperation { () -&gt; Void in<br>    NSLog(“下载图片 - %@”, NSThread.currentThread())<br>    NSThread.sleepForTimeInterval(1.0)<br>}</p>
<p>//2.任务二：打水印<br>let operation2 = NSBlockOperation { () -&gt; Void in<br>    NSLog(“打水印   - %@”, NSThread.currentThread())<br>    NSThread.sleepForTimeInterval(1.0)<br>}</p>
<p>//3.任务三：上传图片<br>let operation3 = NSBlockOperation { () -&gt; Void in<br>    NSLog(“上传图片 - %@”, NSThread.currentThread())<br>    NSThread.sleepForTimeInterval(1.0)<br>}</p>
<p>//4.设置依赖<br>operation2.addDependency(operation1)    //任务二依赖任务一<br>operation3.addDependency(operation2)    //任务三依赖任务二</p>
<p>//5.创建队列并加入任务<br>let queue = NSOperationQueue()<br>queue.addOperations([operation3, operation2, operation1], waitUntilFinished: false)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">打印结果</div></pre></td></tr></table></figure></p>
<p>2015-07-28 21:24:28.622 test[19392:4637517] 下载图片 - <nsthread: 0x7fc10ad4d970="">{number = 2, name = (null)}<br>2015-07-28 21:24:29.622 test[19392:4637515] 打水印   - <nsthread: 0x7fc10af20ef0="">{number = 3, name = (null)}<br>2015-07-28 21:24:30.627 test[19392:4637515] 上传图片 - <nsthread: 0x7fc10af20ef0="">{number = 3, name = (null)}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。</div><div class="line">* 可以使用 `removeDependency` 来解除依赖关系。</div><div class="line">* 可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</div><div class="line"></div><div class="line">### 其他方法</div><div class="line"></div><div class="line">* **NSOperation**</div></pre></td></tr></table></figure></nsthread:></nsthread:></nsthread:></p>
<p>BOOL executing;                   //判断任务是否正在执行<br>BOOL finished;                    //判断任务是否完成<br>void (^completionBlock)(void);        //用来设置完成后需要执行的操作</p>
<ul>
<li>(void)cancel;                  //取消任务</li>
<li>(void)waitUntilFinished;           //阻塞当前线程直到此任务执行完毕</li>
</ul>
<p>// 依赖: NSOperation之间可以设置依赖来保证执行顺序<br>// 1.比如一定要让操作A执行完后，才能执行操作B，可以这么写<br>[operationB addDependency:operationA];<br>// 操作B依赖于操作A注意：可以在不同queue的NSOperation之间创建依赖关系</p>
<p>// 操作的监听<br>// 1.可以监听一个操作的执行完毕</p>
<ul>
<li>(void(^)(void))completionBlock;</li>
<li>(void)setCompletionBlock:(void(^)(void))block;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* **NSOperationQueue**</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NSUInteger operationCount;        //获取队列的任务数</p>
<ul>
<li>(void)waitUntilAllOperationsAreFinished;   //阻塞当前线程直到此队列中的所有任务执行完毕</li>
</ul>
<p>// 最大并发数: 可以通过对最大并发数设置，控制程序中线程的数量</p>
<p>// 1.最大并发数的相关方法</p>
<ul>
<li>(NSInteger)maxConcurrentOperationCount;</li>
<li>(void)setMaxConcurrentOperationCount:(NSInteger)cnt;</li>
</ul>
<p>// 取消、暂停、恢复<br>// 1.取消队列的所有操作</p>
<ul>
<li>(void)cancelAllOperations;<br>// 2.取消单个操作</li>
<li>(void)cancel;<br>// 暂停queue</li>
<li>(void)setSuspended:(BOOL)b;<br>// YES代表暂停队列，NO代表继续队列<br>[queue setSuspended:YES];         // 暂停queue<br>[queue setSuspended:NO];          // 继续queue</li>
</ul>
<p>// 恢复队列</p>
<ul>
<li>(BOOL)isSuspended;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 多线程运用</div><div class="line"></div><div class="line">### 线程同步</div><div class="line"></div><div class="line">所谓线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</div><div class="line">* **互斥锁** ：给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</div><div class="line"></div><div class="line">OBJECTIVE-C</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@synchronized(self) {<br>  //需要执行的代码块<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure></p>
<p>objc_sync_enter(self)<br>//需要执行的代码块<br>objc_sync_exit(self)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* **同步执行** ：我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 GCD 和 NSOperation 两种方案:</div></pre></td></tr></table></figure></p>
<p>//GCD<br>//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中<br>dispatch_sync(queue, ^{<br>    NSInteger ticket = lastTicket;<br>    [NSThread sleepForTimeInterval:0.1];<br>    NSLog(@”%ld - %@”,ticket, [NSThread currentThread]);<br>    ticket -= 1;<br>    lastTicket = ticket;<br>});</p>
<p>//NSOperation &amp; NSOperationQueue<br>//重点：  1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中<br>//       2. 设置 queue 的 maxConcurrentOperationCount 为 1<br>//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</p>
<p>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{<br>    NSInteger ticket = lastTicket;<br>    [NSThread sleepForTimeInterval:1];<br>    NSLog(@”%ld - %@”,ticket, [NSThread currentThread]);<br>    ticket -= 1;<br>    lastTicket = ticket;<br>}];</p>
<p>[queue addOperation:operation];</p>
<p>[operation waitUntilFinished];</p>
<p>//后续要做的事<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 延迟执行</div><div class="line"></div><div class="line">所谓延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</div><div class="line"></div><div class="line">* perform</div></pre></td></tr></table></figure></p>
<p>// 3秒后自动调用self的run:方法，并且传递参数：@”abc”<br>[self performSelector:@selector(run:) withObject:@”abc” afterDelay:3];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* GCD</div><div class="line"></div><div class="line">可以使用 GCD 中的 dispatch_after 方法</div></pre></td></tr></table></figure></p>
<p>// 创建队列<br>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>// 设置延时，单位秒<br>double delay = 3; </p>
<p>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{<br>  // 3秒后需要执行的任务<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* NSTimer</div><div class="line"></div><div class="line">NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法，不过这里直说延迟执行的用法。</div></pre></td></tr></table></figure></p>
<p>[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@”abc” repeats:NO];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 单例模式</div></pre></td></tr></table></figure></p>
<p>static HLUserManager *_singleton = nil;</p>
<p>@implementation HLUserManager</p>
<ul>
<li><p>(instancetype)sharedManager {</p>
<p>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{</p>
<pre><code>_singleton = [[HLUserManager alloc] init];
</code></pre><p>  });<br>  return _singleton;<br>}</p>
</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面看 Swift 中的单例模式，在Swift中单例模式非常简单！想知道怎么从 OC 那么复杂的方法变成下面的写法的，[请看这里](http://www.devtf.cn/?p=937)</div><div class="line"></div><div class="line">SWIFT</div></pre></td></tr></table></figure></p>
<p>class Tool: NSObject {<br>    static let sharedTool = Tool()</p>
<pre><code>// 私有化构造方法，阻止其他对象使用这个类的默认的&apos;()&apos;构造方法
private override init() {}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 从其他线程回到主线程的方法</div><div class="line"></div><div class="line">我们都知道在其他线程操作完成后必须到主线程更新UI。所以，介绍完所有的多线程方案后，我们来看看有哪些方法可以回到主线程。</div><div class="line"></div><div class="line">* NSThread</div></pre></td></tr></table></figure></p>
<p>//Objective-C<br>[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</p>
<p>//Swift<br>//swift 取消了 performSelector 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* GCD</div></pre></td></tr></table></figure></p>
<p>//Objective-C<br>dispatch_async(dispatch_get_main_queue(), ^{</p>
<p>});</p>
<p>//Swift<br>dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in</p>
<p>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* NSOperationQueue</div></pre></td></tr></table></figure></p>
<p>//Objective-C<br>[[NSOperationQueue mainQueue] addOperationWithBlock:^{</p>
<p>}];</p>
<p>//Swift<br>NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">线程的状态</div><div class="line"></div><div class="line">![](http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)</div><div class="line"></div><div class="line">多线程的安全隐患</div><div class="line"></div><div class="line">一块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源。</div><div class="line">当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。</div><div class="line">![](http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3.png)</div><div class="line"></div><div class="line">解决办法：（互斥锁）</div><div class="line">![](http://ofutv2nt8.bkt.clouddn.com/blog/duoxiancheng/%E4%BA%92%E6%96%A5%E9%94%81.png)</div></pre></td></tr></table></figure></p>
<p>// 注意：锁定1份代码只用1把锁，用多把锁是无效的<br>@synchronized(锁对象) {<br>// 需要锁定的代码<br>};<br>```<br>如果给数据加了锁，就等于将这些异步的子线程变成同步的了，这也叫做线程同步技术。</p>
<p><strong>优点与缺点</strong></p>
<p>能有效防止因多线程抢夺资源造成的数据安全问题</p>
<p>需要消耗大量的CPU资源</p>
<ul>
<li>Critical Section (临界区)<br>简而言之就是两个或多个线程不能同时执行一段代码去操作一个共享的资源</li>
<li>Race Condition (竞态条件)<br>这种情况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，<br>竞态条件可导致无法预测的行为，例如程序的并发任务执行的确切顺序</li>
<li>Deadlock (死锁)<br>所谓的死锁是指两个(或多个)线程都卡住了，都在等待对方完成后执行，<br>第一个不能完成是因为在等待第二个的完成，但第二个也不能完成，<br>是因为它在等待第一个完成</li>
</ul>
<p>atomic与nonatomic</p>
<p>OC在定义属性时有nonatomic和atomic两种选择</p>
<p>@property(nonatomic,copy)NSString<em>name;<br>@property(atomic,copy)NSString</em>name;</p>
<p>atomic：原子属性，为setter方法加锁（默认就是atomic）<br>线程安全，需要消耗大量的资源</p>
<p>nonatomic：非原子属性，不会为setter方法加锁<br>非线程安全，适合内存小的移动设备</p>
<p>开发建议</p>
<p>所有属性都声明为nonatomic</p>
<p>尽量避免多线程抢夺同一块资源</p>
<p>尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</p>
<p><img src="/2017/12/29/multithreading/1.jpg" alt=""></p>
<p><a href="http://www.jianshu.com/p/5dfe92d28746" target="_blank" rel="external">原文链接</a><br>作者：cactus_Hsia<br>链接：<a href="https://www.jianshu.com/p/ddbb152bfbd8" target="_blank" rel="external">https://www.jianshu.com/p/ddbb152bfbd8</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/27/Launch-Image/" rel="next" title="Launch Image 设置">
                <i class="fa fa-chevron-left"></i> Launch Image 设置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/31/gradient-view/" rel="prev" title="渐变view">
                渐变view <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofutv2nt8.bkt.clouddn.com/blog/image/xiamu.jpeg"
               alt="安国立" />
          <p class="site-author-name" itemprop="name">安国立</p>
          <p class="site-description motion-element" itemprop="description">留给中国队的时间不多了</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/AnGuoli" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/5a1678e7f265da432c23856e" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-joomla"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/98bd5a3ecd08" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-jsfiddle"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#主线程"><span class="nav-number">1.1.</span> <span class="nav-text">主线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pthreads"><span class="nav-number">1.2.</span> <span class="nav-text">Pthreads</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSThread"><span class="nav-number">1.3.</span> <span class="nav-text">NSThread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建并启动"><span class="nav-number">1.3.1.</span> <span class="nav-text">创建并启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">其他方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD"><span class="nav-number">1.4.</span> <span class="nav-text">GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任务和队列"><span class="nav-number">1.4.1.</span> <span class="nav-text">任务和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#任务：执行什么操作"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">任务：执行什么操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列：用来存放任务"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">队列：用来存放任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建任务"><span class="nav-number">1.4.2.</span> <span class="nav-text">创建任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建队列"><span class="nav-number">1.4.3.</span> <span class="nav-text">创建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD运用"><span class="nav-number">1.4.4.</span> <span class="nav-text">GCD运用</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安国立</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
