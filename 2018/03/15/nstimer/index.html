<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="You use the NSTimer class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object. For">
<meta property="og:type" content="article">
<meta property="og:title" content="NSTimer">
<meta property="og:url" content="http://yoursite.com/2018/03/15/nstimer/index.html">
<meta property="og:site_name" content="An Guoli's Blog">
<meta property="og:description" content="You use the NSTimer class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object. For">
<meta property="og:image" content="http://yoursite.com/2018/03/15/nstimer/nstimer-retain-circle.png">
<meta property="og:updated_time" content="2018-03-19T11:55:17.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NSTimer">
<meta name="twitter:description" content="You use the NSTimer class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object. For">
<meta name="twitter:image" content="http://yoursite.com/2018/03/15/nstimer/nstimer-retain-circle.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/15/nstimer/"/>





  <title> NSTimer | An Guoli's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>
<a href="https://github.com/anguoli"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">An Guoli's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/nstimer/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="安国立">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofutv2nt8.bkt.clouddn.com/blog/image/xiamu.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="An Guoli's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="An Guoli's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                NSTimer
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-15T10:16:36+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>You use the NSTimer class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object. For example, you could create an NSTimer object that sends a message to a window, telling it to update itself after a certain time interval.</p>
<p>这段话的意思简单的来说就是NSTimer是一个定时器，能够在每个确定时间间隔里发送信息给对象。</p>
</blockquote>
<h2 id="NSRunLoop"><a href="#NSRunLoop" class="headerlink" title="NSRunLoop"></a>NSRunLoop</h2><p>谈到定时器，首先需要了解的一个概念是 NSRunLoop。NSRunLoop 是消息处理的一种机制，类似于 Windows 中的消息循环、Node.js 的事件处理，有个更通用的叫法是 Event Loop。</p>
<p>其原理很简单，启动一个循环，无限地重复接受消息-&gt;等待消息-&gt;处理消息这个过程，直到退出。伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void loop() &#123;</div><div class="line">    do &#123;</div><div class="line">        void *msg = getMessage();</div><div class="line">        processMessage(msg);</div><div class="line">    &#125; while (msg != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个线程内部都会有一个 RunLoop，启动 RunLoop 之后，就能够让线程在没有消息时休眠，在有消息时被唤醒并处理消息，避免资源长期被占用。</p>
<p>在 iOS 中，NSThead 和 NSRunLoop 是一一对应的，但创建线程的时候不会默认创建 NSRunLoop，实际上也不允许自己创建 NSRunLoop，在线程内第一次调用[NSRunLoop currentRunLoop]的时候才会自动创建。<br>苹果不允许自己创建RunLoop，但是提供了两个方法来获取线程的RunLoop：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p>
<p>在cocoaTouch框架中只有主线程的RunLoop是默认打开的.</p>
<p>RunLoop有几个Mode，他们分别是：</p>
<p>1：kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。</p>
<p>2：UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。</p>
<p>3：UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>
<p>4：GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>
<p>5：kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。(是一个模式集合，当绑定一个事件源到这个模式集合的时候就相当于绑定到了集合内的每一个模式。)在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义modes。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="创建timer"><a href="#创建timer" class="headerlink" title="创建timer"></a>创建timer</h2><p>NSTimer的几种创建方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div></pre></td></tr></table></figure>
<p>常用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div></pre></td></tr></table></figure>
<p>三种方法的区别是：</p>
<p>scheduledTimerWithTimeInterval方法不仅创建了NSTimer对象，还把该NSTimer对象加入到了当前线程的RunLoop（默认NSDefaultRunLoopModel模式）中。<br>前两个方法需要使用addTimer:forMode:方法将NSTimer加入到RunLoop中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode;</div></pre></td></tr></table></figure>
<p>具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(repeat:) userInfo:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125; repeats:true];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(repeat:) userInfo:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125; repeats:true];</div><div class="line">[[NSRunLoop currentRunLoop] addTimer: _timer forMode:NSDefaultRunLoopMode];</div></pre></td></tr></table></figure>
<p>以上三种方式都是在 RunLoop 的 Mode为 NSDefaultRunLoopMode 时触发, 在滚动scrollView的时候NSTimer会停止工作. </p>
<h3 id="NSTimer和RunLoop"><a href="#NSTimer和RunLoop" class="headerlink" title="NSTimer和RunLoop"></a>NSTimer和RunLoop</h3><p><strong>滑动 ScrollView 时 NSTimer 不工作的问题</strong></p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)target selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats</div></pre></td></tr></table></figure>
<p> forMode的参数有两种类型可供选择： <code>NSDefaultRunLoopMode</code> ， <code>NSRunLoopCommonModes</code>，第一个参数为默认参数，</p>
<p>当前线程就是主线程，也就是UI线程时，某些UI事件，比如UIScrollView的拖动操作，会将 RunLoop 切换成 <code>NSEventTrackingRunLoopMode</code> 模式，在这个过程中，默认的 <code>NSDefaultRunLoopMode</code> 模式中注册的事件是不会被执行的。<br><code>NSRunLoopCommonModes</code> 能够在多线程中起作用，这个模式等效于<code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code> 的结合，这也是将modes换为 <code>NSRunLoopCommonModes</code> 便可解决的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; </div><div class="line">[runLoop addTimer:timer forMode: NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h2 id="NSTimer的触发"><a href="#NSTimer的触发" class="headerlink" title="NSTimer的触发"></a>NSTimer的触发</h2><p>当定时器创建完（不用scheduled的)，添加到runloop中后，该定时器将在初始化时指定的timeInterval秒后自动触发。</p>
<p>可以使用<code>-(void)fire;</code>方法来立即触发该定时器；</p>
<blockquote>
<p>You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived.</p>
<p> 在重复执行的定时器中调用此方法后立即触发该定时器，但不会中断其之前的执行计划；<br>在不重复执行的定时器中调用此方法，立即触发后，就会使这个定时器失效。</p>
</blockquote>
<p>调用fire的时候，立即触发timer的方法，该方法触发不影响计时器原本的计时，只是新增一次触发</p>
<p>当NSTimer进入后台的时，NSTimer计时暂停，进入前台继续</p>
<h3 id="子线程中NSTimer的坑"><a href="#子线程中NSTimer的坑" class="headerlink" title="子线程中NSTimer的坑"></a>子线程中NSTimer的坑</h3><p>1.必须保证有一个活跃的runloop。</p>
<p>NSObject 的 <code>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</code> 也可以用于延迟一段时间执行特定的代码.该方法内部是启用一个Timer并添加到当前线程的runloop，原理与NSTimer一样.</p>
<p><code>performSelector</code> 和 <code>scheduledTimerWithTimeInterval</code> 方法都是基于runloop的。我们知道，当一个应用启动时，系统会开启一个主线程，并且把主线程的runloop激活，也就是run起来，并且主线程的runloop是不会停止的。所以，当这两个方法在主线程可以被正常调用。但情况往往不是这样的。实际编码中，我们更多的逻辑是放在子线程中执行的。而子线程的runloop是默认关闭的。这时如果不手动激活runloop，<code>performSelector</code> 和 <code>scheduledTimerWithTimeInterval</code> 的调用将是无效的。</p>
<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@implementation SecondController &#123;</div><div class="line">    NSTimer *_testTimer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    NSLog(@&quot;1:%p&quot;, [NSRunLoop currentRunLoop]);</div><div class="line">    [self performSelectorInBackground:@selector(testTimer) withObject:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testTimer &#123;</div><div class="line">    NSLog(@&quot;2:%p&quot;, [NSRunLoop currentRunLoop]);</div><div class="line">    _testTimer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(handleTestTimer) userInfo:nil repeats:YES];</div><div class="line">    [[NSRunLoop currentRunLoop] addTimer:_testTimer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    if (_testTimer.isValid) &#123;</div><div class="line">        [_testTimer invalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;dealloc!&quot;);</div><div class="line">    [_testTimer invalidate];</div><div class="line">    _testTimer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleTestTimer &#123;</div><div class="line">    NSLog(@&quot;hello world!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当我们用performSelector的方式把timer放到子线程中的runloop里时发现timer不好使了。</p>
<p>子线程默认不会创建 runloop ，currentRunloop的方式是可以获得 runloop 的，在线程内第一次调用 <code>[NSRunLoop currentRunLoop]</code> 的时候才会自动创建。但是此时的这个runloop并没有run(激活)，我们要在 <code>[[NSRunLoop currentRunLoop] addTimer:_testTimer forMode:NSDefaultRunLoopMode];</code> 后调用 <code>[[NSRunLoop currentRunLoop] run];</code> 才可以使得这个timer正常工作。</p>
<p>总结:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] run];</div></pre></td></tr></table></figure>
<p>这行代码的作用就是打开当前线程的runLoop，在cocoaTouch框架中只有主线程的RunLoop是默认打开的，而其他线程的RunLoop如果需要使用就必须手动打开，所以如果我们是想要添加到主线程的RunLoop的话，是不需要手动打开RunLoop的。</p>
<h2 id="停止timer"><a href="#停止timer" class="headerlink" title="停止timer"></a>停止timer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)invalidate;</div></pre></td></tr></table></figure>
<p>这个是唯一一个可以将计时器从runloop中移出的方法,并删除了runloop对计时器的强引用,也是唯一去除对target强引用的方法</p>
<p>苹果文档:</p>
<blockquote>
<p>Stops the timer from ever firing again and requests its removal from its run loop.</p>
<p>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.</p>
<p>If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.</p>
</blockquote>
<p>意思是：</p>
<ul>
<li>invalidate方法会停止计时器的再次触发，并在RunLoop中将其移除。</li>
<li>invalidate方法是将NSTimer对象从RunLoop中移除的唯一方法。</li>
<li>调用invalidate方法会删除RunLoop对NSTimer的强引用，以及NSTimer对target和userInfo的强引用</li>
</ul>
<p>那为什么RunLoop会对NSTimer强引用呢？</p>
<blockquote>
<p>Timers work in conjunction with run loops. Run loops maintain strong references to their timers<br>（ 计时器与运行循环一起工作。Run loops维护对计时器的强引用）</p>
</blockquote>
<p>在 invalidate 方法的文档里还有这这样一段话：</p>
<blockquote>
<p>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.</p>
</blockquote>
<p>NSTimer的创建与撤销必须在同一个线程操作、performSelector的创建与撤销必须在同一个线程操作。</p>
<h2 id="循环引用导致的内存泄露的问题"><a href="#循环引用导致的内存泄露的问题" class="headerlink" title="循环引用导致的内存泄露的问题"></a>循环引用导致的内存泄露的问题</h2><p>NSTimer 添加到 Runloop 的时候，会被 Runloop 强引用：</p>
<blockquote>
<p>Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.</p>
</blockquote>
<p>当timer触发后，在调用invalidated之前会一直保持对target的强引用也就是 self</p>
<blockquote>
<p>Target is the object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated.</p>
</blockquote>
<p>也就是说 NSTimer 强引用了 self ，导致 self 一直不能被释放掉，所以走不到 self 的 dealloc 里。</p>
<p><img src="/2018/03/15/nstimer/nstimer-retain-circle.png" alt="NSTimer的循环引用"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@implementation SecondController &#123;</div><div class="line">    NSTimer *_testTimer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    _testTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(handleTestTimer) userInfo:nil repeats:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">  NSLog(@&quot;dealloc!&quot;);</div><div class="line">    [_testTimer invalidate];</div><div class="line">     _testTimer = nil;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleTestTimer &#123;</div><div class="line">    NSLog(@&quot;hello world!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可能写过类似上面的代码，一般情况下它是可以正常执行的，我们并没有过多的去想timer的问题，但是实际上这样写是有问题的。如果创建timer时repeats:YES，再运行的话，我们发现dealloc函数就永远不会调用了(我们这里SecondController是被另一个vc push进来的)。</p>
<p>引起这个问题的原因就是：timer会强引用自己的target，在上面的例子中，我们的vc是强引用_testTimer对象的，但是创建这个timer的时候我们的target传入的是self，此时就导致了tiemr也强引用了self，导致循环引用的产生。</p>
<p>准确的说，timer在isValid为YES的时候(当timer触发后，在调用invalidated之前)是强引用自己的target的，所以一般我们都把invalidate的时机放在viewWillDisappear:或viewDidDisappear:的时候，这样vc就会正常释放了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation SecondController &#123;</div><div class="line">    NSTimer *_testTimer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    _testTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(handleTestTimer) userInfo:nil repeats:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    if (_testTimer.isValid) &#123;</div><div class="line">        [_testTimer invalidate];</div><div class="line">        _testTimer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;dealloc!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleTestTimer &#123;</div><div class="line">    NSLog(@&quot;hello world!&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面这样就可以正常释放了，</p>
<p>但这里还要说一点：</p>
<p>循环引用和内存泄露还是稍有不同的</p>
<p>就拿我们的timer举例，如果我们在创建timer的时候repeats:NO，但是触发的时机是30s，但是我们在这个vc中停留小于30s，就会造成暂时的循环引用，但是这种情况也不能说是内存泄露，从我们退出vc开始到timer触发时的这一段时间内，vc和timer造成了循环引用，但是当timer触发后，你会发现，vc的dealloc也被调用了，此时vc和timer的内存都能够得到释放，循环引用是有暂时性的，所以要理解循环引用和内存泄露是稍有不同的。</p>
<p>当定时器是不重复的（repeat=NO），在执行完触发函数后，会自动调用invalidate解除runloop的注册和解除对target的强引用</p>
<h2 id="几种成熟的解决循环引用方案"><a href="#几种成熟的解决循环引用方案" class="headerlink" title="几种成熟的解决循环引用方案"></a>几种成熟的解决循环引用方案</h2><h3 id="一-使用自定义Category用Block解决"><a href="#一-使用自定义Category用Block解决" class="headerlink" title="一. 使用自定义Category用Block解决"></a>一. 使用自定义Category用Block解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSTimer+AYWeakTimer.h</div><div class="line"></div><div class="line">@interface NSTimer (AYWeakTimer)</div><div class="line">+ (NSTimer *)ay_scheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval block:(void (^)(void))eventBlock repeats:(BOOL)repeats;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSTimer+AYWeakTimer.m</div><div class="line"></div><div class="line">@implementation NSTimer (AYWeakTimer)</div><div class="line"></div><div class="line">+ (NSTimer *)ay_scheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval block:(void (^)(void))eventBlock repeats:(BOOL)repeats</div><div class="line">&#123;</div><div class="line">    NSTimer *timer = [self scheduledTimerWithTimeInterval:timeInterval target:self selector:@selector(ay_executeTimer:) userInfo:[eventBlock copy] repeats:repeats];</div><div class="line">    </div><div class="line">    return timer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)ay_executeTimer:(NSTimer *)timer</div><div class="line">&#123;</div><div class="line">    void (^block)(void) = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>定义一个NSTimer的类别，在类别中定义一个类方法。类方法有一个类型为块的参数（定义的块位于栈上，为了防止块被释放，需要调用copy方法，将块移到堆上）。<br>使用这个类别的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__weak ViewController *weakSelf = self;</div><div class="line">_timer = [NSTimer ay_scheduledTimerWithTimeInterval:5.0 block:^&#123; __strong ViewController *strongSelf = weakSelf;</div><div class="line">[strongSelf startCounting]; &#125; repeats:YES];</div></pre></td></tr></table></figure>
<p>使用这种方案就可以防止NSTimer对类的保留，从而打破了循环引用的产生。__strong ViewController *strongSelf = weakSelf<br>主要是为了防止执行块的代码时，类被释放了。<br>在类的dealloc方法中，记得调用[_timer invalidate]。</p>
<p>定时器对象指定的target是NSTimer类对象是个单例，因此计时器是否会保留它都无所谓。这么做，循环引用依然存在，但是因为类对象无需回收，所以能解决问题。</p>
<p>优点：代码简洁，逻辑清晰</p>
<p>缺点：</p>
<ol>
<li>需要使用weakSelf避免block循环引用</li>
<li>不再使用原生API</li>
<li>同时要为NSTimer何CADisplayLink分别引进一个Category</li>
</ol>
<h3 id="二-GCD自己实现Timer"><a href="#二-GCD自己实现Timer" class="headerlink" title="二. GCD自己实现Timer"></a>二. GCD自己实现Timer</h3><p>直接用GCD自己实现一个定时器，YYKit直接有一个现成的类<a href="https://github.com/ibireme/YYKit/tree/master/YYKit/Utility" target="_blank" rel="external">YYTimer</a>这里不再赘述。<br>缺点:代价有点大，需要自己重新造一个定时器。</p>
<h3 id="三-代理NSProxy"><a href="#三-代理NSProxy" class="headerlink" title="三. 代理NSProxy"></a>三. 代理NSProxy</h3><p>使用工具类<a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.h" target="_blank" rel="external">YYWeakProxy</a>解决NSTimer/CADisplayLink循环引用问题！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">YYWeakProxy.h</div><div class="line">@interface YYWeakProxy : NSProxy</div><div class="line">@property (nonatomic, weak, readonly) id target;</div><div class="line">-(instancetype)initWithTarget:(id)target;</div><div class="line">+(instancetype)proxyWithTarget:(id)target;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">YYWeakProxy.m</div><div class="line">-(instancetype)initWithTarget:(id)target &#123;</div><div class="line"> _target = target;</div><div class="line"> return self;</div><div class="line">&#125;</div><div class="line">+(instancetype)proxyWithTarget:(id)target &#123;</div><div class="line"> return [[YYWeakProxy alloc] initWithTarget:target];</div><div class="line">&#125;</div><div class="line">-(id)forwardingTargetForSelector:(SEL)selector &#123;</div><div class="line"> return _target;</div><div class="line">&#125;</div><div class="line">-(void)forwardInvocation:(NSInvocation *)invocation &#123;</div><div class="line"> void *null = NULL;</div><div class="line"> [invocation setReturnValue:&amp;null];</div><div class="line">&#125;</div><div class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</div><div class="line"> return [NSObject instanceMethodSignatureForSelector:@selector(init)];</div><div class="line">&#125;</div><div class="line">-(BOOL)respondsToSelector:(SEL)aSelector &#123;</div><div class="line"> return [_target respondsToSelector:aSelector];</div><div class="line">&#125;</div><div class="line">-(BOOL)isEqual:(id)object &#123;</div><div class="line"> return [_target isEqual:object];</div><div class="line">&#125;</div><div class="line">-(NSUInteger)hash &#123;</div><div class="line"> return [_target hash];</div><div class="line">&#125;</div><div class="line">-(Class)superclass &#123;</div><div class="line"> return [_target superclass];</div><div class="line">&#125;</div><div class="line">-(Class)class &#123;</div><div class="line"> return [_target class];</div><div class="line">&#125;</div><div class="line">-(BOOL)isKindOfClass:(Class)aClass &#123;</div><div class="line"> return [_target isKindOfClass:aClass];</div><div class="line">&#125;</div><div class="line">-(BOOL)isMemberOfClass:(Class)aClass &#123;</div><div class="line"> return [_target isMemberOfClass:aClass];</div><div class="line">&#125;</div><div class="line">-(BOOL)conformsToProtocol:(Protocol *)aProtocol &#123;</div><div class="line"> return [_target conformsToProtocol:aProtocol];</div><div class="line">&#125;</div><div class="line">-(BOOL)isProxy &#123;</div><div class="line"> return YES;</div><div class="line">&#125;</div><div class="line">-(NSString *)description &#123;</div><div class="line"> return [_target description];</div><div class="line">&#125;</div><div class="line">-(NSString *)debugDescription &#123;</div><div class="line"> return [_target debugDescription];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>该方法引入一个YYWeakProxy对象，在这个对象中弱引用真正的目标对象。通过YYWeakProxy对象，将NSTimer/CADisplayLink对象弱引用目标对象。</p>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1</div><div class="line">                                                  target:[YYWeakProxy proxyWithTarget:self]</div><div class="line">                                                selector:@selector(timeEvent)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:YES];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)timeEvent&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc</div><div class="line">&#123;</div><div class="line">    [self.timer invalidate];</div><div class="line">    self.timer = nil;// 对象置nil是一种规范和习惯</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>为什么NSProxy的子类YYWeakProxy可以解决呢？</strong></p>
<ul>
<li>NSProxy本身是一个抽象类，它遵循NSObject协议，提供了消息转发的通用接口，NSProxy通常用来实现消息转发机制和惰性初始化资源。不能直接使用NSProxy。需要创建NSProxy的子类，并实现init以及消息转发的相关方法，才可以用。</li>
<li>YYWeakProxy继承了NSProxy，定义了一个弱引用的target对象，通过重写消息转发等关键方法，让target对象去处理接收到的消息。在整个引用链中，Controller对象强引用NSTimer/CADisplayLink对象，NSTimer/CADisplayLink对象强引用YYWeakProxy对象，而YYWeakProxy对象弱引用Controller对象，所以在YYWeakProxy对象的作用下，Controller对象和NSTimer/CADisplayLink对象之间并没有相互持有，完美解决循环引用的问题。</li>
</ul>
<h2 id="NSTimer-不精确"><a href="#NSTimer-不精确" class="headerlink" title="NSTimer 不精确"></a>NSTimer 不精确</h2><p><strong>可靠性</strong></p>
<p>不可靠.</p>
<p>1.其所在的 RunLoop 会定时检测是否可以触发 NSTimer 的事件，但由于 iOS 有多个 RunLoop 的运行模式，如果被切到另一个 run loop mode，在别的模式中注册的NSTimer的事件就不会被触发。</p>
<p>2.每个 RunLoop 的循环间隔也无法保证，当某个任务耗时比较久，RunLoop 的下一个消息处理就只能顺延，导致 NSTimer 的时间已经到达，但 Runloop 却无法及时触发 NSTimer，导致该时间点的回调被错过。NSTimer不会延后执行，而是会等下一次触发，相当于等公交错过了，只能等下一趟车，tolerance属性可以设置误差范围</p>
<p>苹果官方文档：</p>
<blockquote>
<p>A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer.</p>
</blockquote>
<p><strong>最小精度</strong></p>
<p>理论上最小精度为 0.1 毫秒。不过由于受 Runloop 的影响，会有 50 ~ 100 毫秒的误差，所以，实际精度可以认为是 0.1 秒。</p>
<p>苹果官方文档：</p>
<blockquote>
<p>Because of the various input sources a typical run loop manages, the effective resolution of the time interval for a timer is limited to on the order of 50-100 milliseconds.</p>
</blockquote>
<p><strong>实测结果</strong></p>
<p>间隔 0.1 秒，调用12次。其中倒数第二次调用前会执行一个比较耗时的运算任务。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)startNSTimer &#123;</div><div class="line">    [self setupConfig];</div><div class="line"></div><div class="line">    [self runNSTimerIfNeeded];</div><div class="line"></div><div class="line">    NSLog(@&quot;NSTimer start with interval: %.3f ms, start time: %@, total count: %d&quot;, self.timeInterval * 1000, [self timeStringWithTime:self.startTime], (int)self.maxCount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)runNSTimerIfNeeded &#123;</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:self.timeInterval</div><div class="line">                                     target:self</div><div class="line">                                   selector:@selector(onNSTimerTimeout:)</div><div class="line">                                   userInfo:nil</div><div class="line">                                    repeats:NO];</div><div class="line"></div><div class="line">    self.startTime = [NSDate date];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)onNSTimerTimeout:(NSTimer *)sender &#123;</div><div class="line">    NSLog(@&quot;%d, %@&quot;, ++ self.curCount, [self diffTimeStringFromStart]);</div><div class="line"></div><div class="line">    [self.timer invalidate];</div><div class="line">    self.timer = nil;</div><div class="line"></div><div class="line">    if (self.curCount &lt; self.maxCount) &#123;</div><div class="line">        [self runNSTimerIfNeeded];</div><div class="line">        [self runBusyTaskIfNeeded];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">2016-08-29 11:32:40.302 TimerDemo[37258:10736148] NSTimer start with interval: 100.000 ms, start time: 1472441560302.602 ms, total count: 12</div><div class="line">2016-08-29 11:32:40.403 TimerDemo[37258:10736148] 1, interval: 101.045 ms, discrepancy: 1.045 ms</div><div class="line">2016-08-29 11:32:40.505 TimerDemo[37258:10736148] 2, interval: 100.890 ms, discrepancy: 0.890 ms</div><div class="line">2016-08-29 11:32:40.606 TimerDemo[37258:10736148] 3, interval: 101.087 ms, discrepancy: 1.087 ms</div><div class="line">2016-08-29 11:32:40.707 TimerDemo[37258:10736148] 4, interval: 101.038 ms, discrepancy: 1.038 ms</div><div class="line">2016-08-29 11:32:40.809 TimerDemo[37258:10736148] 5, interval: 101.061 ms, discrepancy: 1.061 ms</div><div class="line">2016-08-29 11:32:40.910 TimerDemo[37258:10736148] 6, interval: 101.069 ms, discrepancy: 1.069 ms</div><div class="line">2016-08-29 11:32:41.012 TimerDemo[37258:10736148] 7, interval: 101.031 ms, discrepancy: 1.031 ms</div><div class="line">2016-08-29 11:32:41.113 TimerDemo[37258:10736148] 8, interval: 101.035 ms, discrepancy: 1.035 ms</div><div class="line">2016-08-29 11:32:41.214 TimerDemo[37258:10736148] 9, interval: 100.890 ms, discrepancy: 0.890 ms</div><div class="line">2016-08-29 11:32:41.315 TimerDemo[37258:10736148] 10, interval: 101.042 ms, discrepancy: 1.042 ms</div><div class="line">2016-08-29 11:32:41.315 TimerDemo[37258:10736148] start busy task</div><div class="line">2016-08-29 11:32:41.970 TimerDemo[37258:10736148] finish busy task</div><div class="line">2016-08-29 11:32:41.970 TimerDemo[37258:10736148] 11, interval: 654.319 ms, discrepancy: 554.319 ms</div><div class="line">2016-08-29 11:32:42.071 TimerDemo[37258:10736148] 12, interval: 100.906 ms, discrepancy: 0.906 ms</div></pre></td></tr></table></figure>
<p>可以看到偏差在 1 ~ 2 毫秒左右。在第 10 次之后执行了一个较耗时的任务，导致第 11 次比预期延迟了 0.5 秒执行。后面的回调仍然按照预设的延时执行。</p>
<p>NSTimer当前所处的线程正在进行耗时操作,这期间有可能会错过很多次NSTimer的循环周期，但是NSTimer并不会将前面错过的执行次数在后面都执行一遍，而是继续执行后面的循环，也就是在一个循环周期内只会执行一次循环。</p>
<p>无论循环延迟的多离谱，循环间隔都不会发生变化，在进行完耗时之后，有可能会立即执行一次NSTimer循环，但是后面的循环间隔始终和第一次添加循环时的间隔相同。</p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>NSTimer不支持后台运行（真机），但是模拟器上App进入后台的时候，NSTimer还会持续触发</p>
<p>如果需要后台运行可以通过下面两种方式支持</p>
<p>让App支持后台运行（运行音频）（在后台可以触发）<br>记录离开和进入App的时间，手动控制计时器（在后台不能触发）<br>第一种控制起来比较麻烦，通常建议手动控制，不在后台触发计时</p>
<h2 id="NSTimer注意点"><a href="#NSTimer注意点" class="headerlink" title="NSTimer注意点"></a>NSTimer注意点</h2><ul>
<li>NSTimer只有被注册到runloop才能起作用，fire不是开启定时器的方法，只是触发一次定时器的方法</li>
<li>NSTimer会强引用target</li>
<li>invalidate取消runloop的注册和target的强引用，如果是非重复的定时器，则在触发时会自动调用invalidate</li>
</ul>
<h2 id="和其他定时器的对比"><a href="#和其他定时器的对比" class="headerlink" title="和其他定时器的对比"></a>和其他定时器的对比</h2><h3 id="NSTimer本质"><a href="#NSTimer本质" class="headerlink" title="NSTimer本质"></a>NSTimer本质</h3><p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>定时器一般用于延迟一段时间执行特定的代码，必要的话按照指定的频率重复执行。iOS 中延时执行有多种方式，常用的有：</p>
<ul>
<li>NSTimer</li>
<li>NSObject 的 (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</li>
<li>CADisplayLink</li>
<li>GCD 的 dispatch_after</li>
<li>GCD 的 dispatch_source_t</li>
</ul>
<p>每种方法创建的定时器，其可靠性与最小精度都有不同。<strong>可靠性</strong>指是否严格按照设定的时间间隔按时执行，<strong>最小精度</strong>指支持的最小时间间隔是多少。</p>
<h3 id="NSObject-的-void-performSelector-SEL-aSelector-withObject-id-anArgument-afterDelay-NSTimeInterval-delay"><a href="#NSObject-的-void-performSelector-SEL-aSelector-withObject-id-anArgument-afterDelay-NSTimeInterval-delay" class="headerlink" title="NSObject 的 (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;"></a>NSObject 的 (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<p>performSelector:withObject:afterDelay:<br>这是 NSObject 对 NSTimer 封装后提供的一个比较简单的延时方法，内部用的也是 NSTimer.</p>
<h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><p>CADisplayLink 是一个和屏幕刷新率(每秒 60 帧，间隔 16.67 ms)一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p>
<p><em>使用方法:</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)runCADisplayLinkTimer &#123;</div><div class="line">    CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(onCADisplayLinkTimeout)];</div><div class="line">    displayLink.frameInterval = 0.0167; // S</div><div class="line">    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line">    self.displayLink = displayLink;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)onCADisplayLinkTimeout &#123;</div><div class="line">    NSLog(@&quot;onCADisplayLinkTimeout&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>可靠性:</em></p>
<p>如果执行的任务很耗时，也会导致回调被错过，所以并不十分可靠。但是，假如调用者能够确保任务能够在最小时间间隔内执行完成，CADisplayLink 就比较可靠，因为屏幕的刷新频率是固定的。</p>
<p><em>最小精度:</em></p>
<p>受限于每秒 60 帧的屏幕刷新频率，注定 CADisplayLink 的最小精度为 16.67 毫秒。误差在 1 毫秒左右。</p>
<p>另外需要注意的是，虽然 CADisplayLink 有一个属性 frameInterval 是用于设置定时器的调用间隔，但是这个属性会在第一次回调之后才生效，对于第一次回调，总是会以 1/60 的间隔来执行的。这样会导致的结果是，比如你设置了每 1 秒执行一次某个方法，但是第一次执行的时候，却是在 16.7 毫秒之后，远远小于预设值。</p>
<p><em>实测结果:</em> </p>
<p>参考: <a href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/" target="_blank" rel="external">更可靠和高精度的 iOS 定时器</a></p>
<p>误差在 0.1 ~ 0.5 毫秒之间，精度比 NSTimer 要高。CADisplayLink 在第一次回调以及在耗时任务之后的回调，精度不可控。</p>
<h3 id="GCD-的-dispatch-after"><a href="#GCD-的-dispatch-after" class="headerlink" title="GCD 的 dispatch_after"></a>GCD 的 dispatch_after</h3><p>dispatch_after 用起来十分简单，代码紧凑易读，而且可以很轻松地在别的线程分配延时任务，所以使用范围很广泛。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    //handle timeout</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>可靠性</em></p>
<blockquote>
<p>Any fire of the timer may be delayed by the system in order to improve power consumption and system performance. The upper limit to the allowable delay may be configured with the ‘leeway’ argument, the lower limit is under the control of the system.</p>
</blockquote>
<p><em>最小精度</em></p>
<p>延时参数的单位是纳秒。如果有延时，则无法保证。</p>
<p><em>实测结果</em></p>
<p>参考: <a href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/" target="_blank" rel="external">更可靠和高精度的 iOS 定时器</a></p>
<p>平均误差 9 毫秒。</p>
<h3 id="GCD-的-dispatch-source-t"><a href="#GCD-的-dispatch-source-t" class="headerlink" title="GCD 的 dispatch_source_t"></a>GCD 的 dispatch_source_t</h3><p>经测试，dispatch_source_t 的最小精度和可靠性都与 diapatch_after 差不多。</p>
<p>参考: <a href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/" target="_blank" rel="external">更可靠和高精度的 iOS 定时器</a></p>
<h3 id="更高精度的定时器"><a href="#更高精度的定时器" class="headerlink" title="更高精度的定时器"></a>更高精度的定时器</h3><p>上述的各种定时器，都受限于苹果为了保护电池和提高性能采用的策略，导致无法实时地执行回调。如果你的确需要使用更高精度的定时器，官方也提供了方法，见 <a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html" target="_blank" rel="external">High Precision Timers in iOS / OS X</a></p>
<p>前面所述的定时器，使用方法各有不同，但其核心代码实际上是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">There are many API’s in iOS and OS X that allow waiting for a specified period of time. They may be Objective C or C, and they take different kinds of arguments, but they all end up using the same code inside the kernel.</div></pre></td></tr></table></figure>
<p>而有别于普通定时器的<a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG5000" target="_blank" rel="external">高精度定时器</a>，则是基于高优先级的线程调度类创建的定时器，在没有多线程冲突的情况下，这类定时器的请求会被优先处理。</p>
<p><em>实现方法</em></p>
<pre><code>- 把定时器所在的线程，移到高优先级的线程调度类。
- 使用更精确的计时器API，换言之，你想要 10 秒后执行，就绝对在 10 秒后执行，绝不提前，也不延迟。
</code></pre><p><em>如何使用</em></p>
<p><a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG6000" target="_blank" rel="external">How do I get put into the real time scheduling class?</a></p>
<p><a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG8000" target="_blank" rel="external">Which timing API(s) should I use?</a></p>
<p>提高调度优先级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;mach/mach.h&gt;</div><div class="line">#include &lt;mach/mach_time.h&gt;</div><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">void move_pthread_to_realtime_scheduling_class(pthread_t pthread) &#123;</div><div class="line">    mach_timebase_info_data_t timebase_info;</div><div class="line">    mach_timebase_info(&amp;timebase_info);</div><div class="line"></div><div class="line">    const uint64_t NANOS_PER_MSEC = 1000000ULL;</div><div class="line">    double clock2abs = ((double)timebase_info.denom / (double)timebase_info.numer) * NANOS_PER_MSEC;</div><div class="line"></div><div class="line">    thread_time_constraint_policy_data_t policy;</div><div class="line">    policy.period      = 0;</div><div class="line">    policy.computation = (uint32_t)(5 * clock2abs); // 5 ms of work</div><div class="line">    policy.constraint  = (uint32_t)(10 * clock2abs);</div><div class="line">    policy.preemptible = FALSE;</div><div class="line"></div><div class="line">    int kr = thread_policy_set(pthread_mach_thread_np(pthread_self()),</div><div class="line">                   THREAD_TIME_CONSTRAINT_POLICY,</div><div class="line">                   (thread_policy_t)&amp;policy,</div><div class="line">                   THREAD_TIME_CONSTRAINT_POLICY_COUNT);</div><div class="line">    if (kr != KERN_SUCCESS) &#123;</div><div class="line">        mach_error(&quot;thread_policy_set:&quot;, kr);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>精确延时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;mach/mach.h&gt;</div><div class="line">#include &lt;mach/mach_time.h&gt;</div><div class="line"></div><div class="line">static const uint64_t NANOS_PER_USEC = 1000ULL;</div><div class="line">static const uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;</div><div class="line">static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;</div><div class="line"></div><div class="line">static mach_timebase_info_data_t timebase_info;</div><div class="line"></div><div class="line">static uint64_t abs_to_nanos(uint64_t abs) &#123;</div><div class="line">    return abs * timebase_info.numer  / timebase_info.denom;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static uint64_t nanos_to_abs(uint64_t nanos) &#123;</div><div class="line">    return nanos * timebase_info.denom / timebase_info.numer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void example_mach_wait_until(int argc, const char * argv[]) &#123;</div><div class="line">    mach_timebase_info(&amp;timebase_info);</div><div class="line">    uint64_t time_to_wait = nanos_to_abs(10ULL * NANOS_PER_SEC);</div><div class="line">    uint64_t now = mach_absolute_time();</div><div class="line">    mach_wait_until(now + time_to_wait);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>最小精度</em></p>
<p>小于 0.5 毫秒。<a href="http://atastypixel.com/blog/wp-content/uploads/2011/09/TPPreciseTimer.zip" target="_blank" rel="external">这里</a>有一份实现的代码以及与普通定时器的对比。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>NSTimer学习笔记 <a href="https://www.jianshu.com/p/07b28a8479ea" target="_blank" rel="external">https://www.jianshu.com/p/07b28a8479ea</a></p>
<p>苹果官方文档 <a href="https://developer.apple.com/documentation/foundation/timer" target="_blank" rel="external">https://developer.apple.com/documentation/foundation/timer</a></p>
<p>深入理解RunLoop <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">https://blog.ibireme.com/2015/05/18/runloop/</a></p>
<p>更可靠和高精度的 iOS 定时器 <a href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/" target="_blank" rel="external">http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/</a></p>
<p>iOS实录8：解决NSTimer/CADisplayLink的循环引用 <a href="https://www.jianshu.com/p/5068b6f02238" target="_blank" rel="external">https://www.jianshu.com/p/5068b6f02238</a></p>
<p>第52条：别忘了NSTimer会保留其目标对象 <a href="https://www.jianshu.com/p/bfaad0dee84b" target="_blank" rel="external">https://www.jianshu.com/p/bfaad0dee84b</a></p>
<p>NSTimer用法与循环引用 <a href="https://www.jianshu.com/p/63d1391d7bb8" target="_blank" rel="external">https://www.jianshu.com/p/63d1391d7bb8</a></p>
<p>选择 GCD 还是 NSTimer ？ <a href="http://www.jianshu.com/p/0c050af6c5ee" target="_blank" rel="external">http://www.jianshu.com/p/0c050af6c5ee</a></p>
<p>iOS开发 之 不要告诉我你会用NSTimer! <a href="http://www.jianshu.com/p/330d7310339d" target="_blank" rel="external">http://www.jianshu.com/p/330d7310339d</a></p>
<p>timer中的那些坑 <a href="http://www.jianshu.com/p/544e2e24eda2" target="_blank" rel="external">http://www.jianshu.com/p/544e2e24eda2</a></p>
<p>深入NSTimer(iOS) <a href="http://www.jianshu.com/p/583ca675065a" target="_blank" rel="external">http://www.jianshu.com/p/583ca675065a</a></p>
<p>iOS笔记之NSTimer <a href="http://www.jianshu.com/p/d17430f4fc0f" target="_blank" rel="external">http://www.jianshu.com/p/d17430f4fc0f</a></p>
<p>iOS 中的 NSTimer <a href="https://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/" target="_blank" rel="external">https://blog.callmewhy.com/2015/07/06/weak-timer-in-ios/</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/12/runloop/" rel="next" title="RunLoop">
                <i class="fa fa-chevron-left"></i> RunLoop
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/17/Retain-Circle/" rel="prev" title="强引用(weak)、弱引用(strong)、dalegate/block/NSTimer中的循环引用、weakSelf、strongSelf">
                强引用(weak)、弱引用(strong)、dalegate/block/NSTimer中的循环引用、weakSelf、strongSelf <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofutv2nt8.bkt.clouddn.com/blog/image/xiamu.jpeg"
               alt="安国立" />
          <p class="site-author-name" itemprop="name">安国立</p>
          <p class="site-description motion-element" itemprop="description">留给中国队的时间不多了</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/AnGuoli" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/5a1678e7f265da432c23856e" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-joomla"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/98bd5a3ecd08" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-jsfiddle"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSRunLoop"><span class="nav-number">1.</span> <span class="nav-text">NSRunLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建timer"><span class="nav-number">2.</span> <span class="nav-text">创建timer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSTimer和RunLoop"><span class="nav-number">2.1.</span> <span class="nav-text">NSTimer和RunLoop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSTimer的触发"><span class="nav-number">3.</span> <span class="nav-text">NSTimer的触发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#子线程中NSTimer的坑"><span class="nav-number">3.1.</span> <span class="nav-text">子线程中NSTimer的坑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止timer"><span class="nav-number">4.</span> <span class="nav-text">停止timer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环引用导致的内存泄露的问题"><span class="nav-number">5.</span> <span class="nav-text">循环引用导致的内存泄露的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几种成熟的解决循环引用方案"><span class="nav-number">6.</span> <span class="nav-text">几种成熟的解决循环引用方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-使用自定义Category用Block解决"><span class="nav-number">6.1.</span> <span class="nav-text">一. 使用自定义Category用Block解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-GCD自己实现Timer"><span class="nav-number">6.2.</span> <span class="nav-text">二. GCD自己实现Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-代理NSProxy"><span class="nav-number">6.3.</span> <span class="nav-text">三. 代理NSProxy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSTimer-不精确"><span class="nav-number">7.</span> <span class="nav-text">NSTimer 不精确</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后台运行"><span class="nav-number">8.</span> <span class="nav-text">后台运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSTimer注意点"><span class="nav-number">9.</span> <span class="nav-text">NSTimer注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和其他定时器的对比"><span class="nav-number">10.</span> <span class="nav-text">和其他定时器的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSTimer本质"><span class="nav-number">10.1.</span> <span class="nav-text">NSTimer本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSObject-的-void-performSelector-SEL-aSelector-withObject-id-anArgument-afterDelay-NSTimeInterval-delay"><span class="nav-number">10.2.</span> <span class="nav-text">NSObject 的 (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CADisplayLink"><span class="nav-number">10.3.</span> <span class="nav-text">CADisplayLink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD-的-dispatch-after"><span class="nav-number">10.4.</span> <span class="nav-text">GCD 的 dispatch_after</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD-的-dispatch-source-t"><span class="nav-number">10.5.</span> <span class="nav-text">GCD 的 dispatch_source_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更高精度的定时器"><span class="nav-number">10.6.</span> <span class="nav-text">更高精度的定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安国立</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
